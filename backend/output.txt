
Путь: d:\golang\DTT\backend\docs\swagger.yaml
Содержимое: 
basePath: /
definitions:
  models.ErrorResponse:
    properties:
      message:
        type: string
      status:
        type: string
    type: object
  models.LoginRequest:
    properties:
      email:
        example: user@example.com
        type: string
      password:
        example: password123
        minLength: 8
        type: string
    required:
    - email
    - password
    type: object
  models.PasswordResetConfirm:
    properties:
      new_password:
        description: |-
          Новый пароль
          required: true
          example: newpassword123
        minLength: 6
        type: string
      token:
        description: |-
          Токен сброса пароля
          required: true
          example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
        type: string
    required:
    - new_password
    - token
    type: object
  models.PasswordResetRequest:
    properties:
      email:
        description: |-
          Email пользователя
          required: true
          example: user@example.com
        type: string
    required:
    - email
    type: object
  models.PermissionAssignmentRequest:
    properties:
      permission_id:
        description: |-
          ID права
          required: true
          example: 1
        example: 1
        type: integer
      role_id:
        description: |-
          ID роли
          required: true
          example: 2
        example: 2
        type: integer
    required:
    - permission_id
    - role_id
    type: object
  models.PermissionRequest:
    properties:
      description:
        description: |-
          Описание права
          example: Delete resources
        example: Delete resources
        type: string
      name:
        description: |-
          Название права
          required: true
          example: delete
        example: delete
        type: string
    required:
    - name
    type: object
  models.ProfileResponse:
    properties:
      avatar:
        type: string
      bio:
        type: string
      email:
        type: string
      first_name:
        type: string
      id:
        type: integer
      last_name:
        type: string
      phone_number:
        type: string
      role:
        type: string
    type: object
  models.RefreshRequest:
    properties:
      refresh_token:
        description: |-
          Refresh токен
          required: true
          example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
        type: string
    required:
    - refresh_token
    type: object
  models.RegisterRequest:
    properties:
      email:
        example: user@example.com
        type: string
      name:
        example: John Doe
        type: string
      password:
        example: password123
        minLength: 8
        type: string
    required:
    - email
    - name
    - password
    type: object
  models.Role:
    properties:
      description:
        type: string
      name:
        type: string
      parent:
        $ref: '#/definitions/models.Role'
      parent_id:
        type: integer
    type: object
  models.RoleAssignmentRequest:
    properties:
      role_id:
        description: |-
          ID роли
          required: true
          example: 2
        example: 2
        type: integer
      user_id:
        description: |-
          ID пользователя
          required: true
          example: 1
        example: 1
        type: integer
    required:
    - role_id
    - user_id
    type: object
  models.RoleRequest:
    properties:
      description:
        description: |-
          Описание роли
          example: Moderator with limited access
        example: Moderator with limited access
        type: string
      name:
        description: |-
          Название роли
          required: true
          example: moderator
        example: moderator
        type: string
    required:
    - name
    type: object
  models.SuccessPermission:
    properties:
      message:
        type: string
      permission:
        type: string
    type: object
  models.SuccessRole:
    properties:
      message:
        type: string
      role:
        $ref: '#/definitions/models.Role'
    type: object
  models.UpdateProfileRequest:
    properties:
      bio:
        type: string
      first_name:
        type: string
      last_name:
        type: string
      phone_number:
        type: string
    type: object
host: localhost:8080
info:
  contact:
    email: support@swagger.io
    name: API Support
  description: API сервер для DTT (Digital Task Tracker)
  license:
    name: Apache 2.0
    url: http://www.apache.org/licenses/LICENSE-2.0.html
  title: DTT API
  version: "1.0"
paths:
  /auth/login:
    post:
      consumes:
      - application/json
      description: Аутентифицирует пользователя и возвращает access и refresh токены
      parameters:
      - description: Учетные данные
        in: body
        name: credentials
        required: true
        schema:
          $ref: '#/definitions/models.LoginRequest'
      produces:
      - application/json
      responses:
        "200":
          description: Успешный логин с токенами
          schema:
            additionalProperties:
              type: string
            type: object
        "400":
          description: Неверный ввод
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "401":
          description: Неверные учетные данные
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "500":
          description: Внутренняя ошибка сервера
          schema:
            $ref: '#/definitions/models.ErrorResponse'
      summary: Аутентификация пользователя
      tags:
      - auth
  /auth/logout:
    post:
      consumes:
      - application/json
      description: Отзывает refresh-токен, завершая сессию пользователя
      parameters:
      - description: Refresh токен
        in: body
        name: refresh
        required: true
        schema:
          $ref: '#/definitions/models.RefreshRequest'
      produces:
      - application/json
      responses:
        "200":
          description: Успешный выход
          schema:
            additionalProperties:
              type: string
            type: object
        "400":
          description: Неверный ввод
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "401":
          description: Неверный refresh-токен
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "500":
          description: Внутренняя ошибка сервера
          schema:
            $ref: '#/definitions/models.ErrorResponse'
      security:
      - Bearer: []
      summary: Выход из системы
      tags:
      - auth
  /auth/password-reset:
    post:
      consumes:
      - application/json
      description: Отправляет токен для сброса пароля на email пользователя
      parameters:
      - description: Email пользователя
        in: body
        name: request
        required: true
        schema:
          $ref: '#/definitions/models.PasswordResetRequest'
      produces:
      - application/json
      responses:
        "200":
          description: Успешная инициация сброса
          schema:
            additionalProperties:
              type: string
            type: object
        "400":
          description: Неверный ввод
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "500":
          description: Внутренняя ошибка сервера
          schema:
            $ref: '#/definitions/models.ErrorResponse'
      summary: Инициация сброса пароля
      tags:
      - auth
  /auth/password-reset/confirm:
    post:
      consumes:
      - application/json
      description: Устанавливает новый пароль с использованием токена сброса
      parameters:
      - description: Токен и новый пароль
        in: body
        name: request
        required: true
        schema:
          $ref: '#/definitions/models.PasswordResetConfirm'
      produces:
      - application/json
      responses:
        "200":
          description: Успешный сброс пароля
          schema:
            additionalProperties:
              type: string
            type: object
        "400":
          description: Неверный ввод
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "401":
          description: Неверный или истекший токен
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "500":
          description: Внутренняя ошибка сервера
          schema:
            $ref: '#/definitions/models.ErrorResponse'
      summary: Сброс пароля
      tags:
      - auth
  /auth/permissions:
    post:
      consumes:
      - application/json
      description: Создает новое право в системе
      parameters:
      - description: Данные права
        in: body
        name: permission
        required: true
        schema:
          $ref: '#/definitions/models.PermissionRequest'
      produces:
      - application/json
      responses:
        "201":
          description: Успешное создание права
          schema:
            $ref: '#/definitions/models.SuccessPermission'
        "400":
          description: Неверный ввод
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "409":
          description: Право уже существует
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "500":
          description: Внутренняя ошибка сервера
          schema:
            $ref: '#/definitions/models.ErrorResponse'
      security:
      - Bearer: []
      summary: Создание права
      tags:
      - auth
  /auth/permissions/assign:
    post:
      consumes:
      - application/json
      description: Назначает указанное право роли
      parameters:
      - description: Данные назначения
        in: body
        name: assignment
        required: true
        schema:
          $ref: '#/definitions/models.PermissionAssignmentRequest'
      produces:
      - application/json
      responses:
        "200":
          description: Успешное назначение права
          schema:
            additionalProperties:
              type: string
            type: object
        "400":
          description: Неверный ввод
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "404":
          description: Роль или право не найдены
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "500":
          description: Внутренняя ошибка сервера
          schema:
            $ref: '#/definitions/models.ErrorResponse'
      security:
      - Bearer: []
      summary: Назначение права роли
      tags:
      - auth
  /auth/refresh:
    post:
      consumes:
      - application/json
      description: Обновляет access-токен используя refresh-токен
      parameters:
      - description: Refresh токен
        in: body
        name: refresh
        required: true
        schema:
          $ref: '#/definitions/models.RefreshRequest'
      produces:
      - application/json
      responses:
        "200":
          description: Успешное обновление токена
          schema:
            additionalProperties:
              type: string
            type: object
        "400":
          description: Неверный ввод
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "401":
          description: Неверный или истекший refresh-токен
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "500":
          description: Внутренняя ошибка сервера
          schema:
            $ref: '#/definitions/models.ErrorResponse'
      security:
      - Bearer: []
      summary: Обновление токена
      tags:
      - auth
  /auth/register:
    post:
      consumes:
      - application/json
      description: Регистрирует нового пользователя в системе
      parameters:
      - description: Данные пользователя
        in: body
        name: user
        required: true
        schema:
          $ref: '#/definitions/models.RegisterRequest'
      produces:
      - application/json
      responses:
        "201":
          description: Успешная регистрация
          schema:
            additionalProperties:
              type: string
            type: object
        "400":
          description: Неверный ввод
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "409":
          description: Пользователь уже существует
          schema:
            $ref: '#/definitions/models.ErrorResponse'
      summary: Регистрация пользователя
      tags:
      - auth
  /auth/roles:
    post:
      consumes:
      - application/json
      description: Создает новую роль в системе
      parameters:
      - description: Данные роли
        in: body
        name: role
        required: true
        schema:
          $ref: '#/definitions/models.RoleRequest'
      produces:
      - application/json
      responses:
        "201":
          description: Успешное создание роли
          schema:
            $ref: '#/definitions/models.SuccessRole'
        "400":
          description: Неверный ввод
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "409":
          description: Роль уже существует
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "500":
          description: Внутренняя ошибка сервера
          schema:
            $ref: '#/definitions/models.ErrorResponse'
      security:
      - Bearer: []
      summary: Создание роли
      tags:
      - auth
  /auth/roles/assign:
    post:
      consumes:
      - application/json
      description: Назначает указанную роль пользователю
      parameters:
      - description: Данные назначения
        in: body
        name: assignment
        required: true
        schema:
          $ref: '#/definitions/models.RoleAssignmentRequest'
      produces:
      - application/json
      responses:
        "200":
          description: Успешное назначение роли
          schema:
            additionalProperties:
              type: string
            type: object
        "400":
          description: Неверный ввод
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "404":
          description: Пользователь или роль не найдены
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "500":
          description: Внутренняя ошибка сервера
          schema:
            $ref: '#/definitions/models.ErrorResponse'
      security:
      - Bearer: []
      summary: Назначение роли пользователю
      tags:
      - auth
  /profile:
    get:
      description: Получает профиль текущего пользователя
      produces:
      - application/json
      responses:
        "200":
          description: Успешное получение профиля
          schema:
            $ref: '#/definitions/models.ProfileResponse'
        "401":
          description: Неавторизован
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "500":
          description: Внутренняя ошибка сервера
          schema:
            $ref: '#/definitions/models.ErrorResponse'
      security:
      - Bearer: []
      summary: Получение профиля
      tags:
      - profile
    put:
      consumes:
      - application/json
      description: Обновляет профиль текущего пользователя
      parameters:
      - description: Данные профиля
        in: body
        name: profile
        required: true
        schema:
          $ref: '#/definitions/models.UpdateProfileRequest'
      produces:
      - application/json
      responses:
        "200":
          description: Успешное обновление профиля
          schema:
            $ref: '#/definitions/models.ProfileResponse'
        "400":
          description: Неверный ввод
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "401":
          description: Неавторизован
          schema:
            $ref: '#/definitions/models.ErrorResponse'
        "500":
          description: Внутренняя ошибка сервера
          schema:
            $ref: '#/definitions/models.ErrorResponse'
      security:
      - Bearer: []
      summary: Обновление профиля
      tags:
      - profile
schemes:
- http
- https
securityDefinitions:
  Bearer:
    description: Type "Bearer" followed by a space and JWT token.
    in: header
    name: Authorization
    type: apiKey
swagger: "2.0"

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\auth\handler\auth_handler.go
Содержимое: 
package handler

import (
	"context"
	"fmt"
	"net/http"

	"backend/internal/auth/middleware"
	"backend/internal/auth/models"
	"backend/internal/auth/service"
	"backend/internal/config"
	"backend/internal/utils"
	customerrors "backend/pkg/errors"

	"github.com/gin-gonic/gin"
)

type AuthHandler struct {
	Service service.AuthServiceInterface
	Config  *config.Config
}

func NewAuthHandler(service service.AuthServiceInterface, cfg *config.Config) *AuthHandler {
	return &AuthHandler{
		Service: service,
		Config:  cfg,
	}
}

// generateTokens генерирует access и refresh токены для пользователя
func (h *AuthHandler) generateTokens(ctx context.Context, userID uint, roleName string, permissions []string) (string, string, error) {
	accessToken, err := utils.GenerateToken(userID, roleName, permissions, h.Config.JWTSecretKey)
	if err != nil {
		return "", "", fmt.Errorf("failed to generate access token: %w", err)
	}
	refreshToken, err := h.Service.GenerateRefreshToken(ctx, userID) // Используем переданный контекст
	if err != nil {
		return "", "", fmt.Errorf("failed to generate refresh token: %w", err)
	}
	return accessToken, refreshToken, nil
}

// Register регистрирует нового пользователя
// @Summary Регистрация пользователя
// @Description Регистрирует нового пользователя в системе
// @Tags auth
// @Accept json
// @Produce json
// @Param user body models.RegisterRequest true "Данные пользователя"
// @Success 201 {object} map[string]string "Успешная регистрация"
// @Failure 400 {object} models.ErrorResponse "Неверный ввод"
// @Failure 409 {object} models.ErrorResponse "Пользователь уже существует"
// @Router /auth/register [post]
func (h *AuthHandler) Register(c *gin.Context) {
	req, ok := middleware.GetRequest[models.RegisterRequest](c)
	if !ok {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid input"})
		return
	}

	// Передаём контекст из запроса
	if err := h.Service.RegisterUser(c.Request.Context(), req.Email, req.Password); err != nil {
		if err == customerrors.ErrUserExists {
			c.JSON(http.StatusConflict, gin.H{"error": "user already exists"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to register user: %v", err)})
		return
	}

	c.JSON(http.StatusCreated, gin.H{"message": "user registered successfully"})
}

// Login аутентифицирует пользователя
// @Summary Аутентификация пользователя
// @Description Аутентифицирует пользователя и возвращает access и refresh токены
// @Tags auth
// @Accept json
// @Produce json
// @Param credentials body models.LoginRequest true "Учетные данные"
// @Success 200 {object} map[string]string "Успешный логин с токенами"
// @Failure 400 {object} models.ErrorResponse "Неверный ввод"
// @Failure 401 {object} models.ErrorResponse "Неверные учетные данные"
// @Failure 500 {object} models.ErrorResponse "Внутренняя ошибка сервера"
// @Router /auth/login [post]
func (h *AuthHandler) Login(c *gin.Context) {
	req, ok := middleware.GetRequest[models.LoginRequest](c)
	if !ok {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid input"})
		return
	}

	user, err := h.Service.AuthenticateUser(req.Email, req.Password)
	if err == customerrors.ErrInvalidCredentials || err == customerrors.ErrUserNotFound {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid credentials"})
		return
	} else if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to authenticate user: %v", err)})
		return
	}
	if user == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "unexpected nil user"})
		return
	}

	userWithRole, err := h.Service.GetUserWithRole(req.Email)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to fetch user role: %v", err)})
		return
	}
	if userWithRole == nil || userWithRole.RoleID == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "unexpected nil user or role"})
		return
	}

	permissions, err := h.Service.GetRolePermissionsRecursive(*userWithRole.RoleID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to fetch permissions: %v", err)})
		return
	}

	accessToken, refreshToken, err := h.generateTokens(c.Request.Context(), user.ID, userWithRole.Role.Name, permissions)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"access_token":  accessToken,
		"refresh_token": refreshToken,
		"token_type":    "Bearer",
	})
}

// CreateRole создает новую роль
// @Summary Создание роли
// @Description Создает новую роль в системе
// @Tags auth
// @Accept json
// @Produce json
// @Param role body models.RoleRequest true "Данные роли"
// @Success 201 {object} models.SuccessRole "Успешное создание роли"
// @Failure 400 {object} models.ErrorResponse "Неверный ввод"
// @Failure 409 {object} models.ErrorResponse "Роль уже существует"
// @Failure 500 {object} models.ErrorResponse "Внутренняя ошибка сервера"
// @Router /auth/roles [post]
// @Security Bearer
func (h *AuthHandler) CreateRole(c *gin.Context) {
	req, ok := middleware.GetRequest[models.RoleRequest](c)
	if !ok {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid input"})
		return
	}

	// Передаём контекст из запроса
	role, err := h.Service.CreateRole(c.Request.Context(), req.Name, req.Description)
	if err == customerrors.ErrUserExists {
		c.JSON(http.StatusConflict, gin.H{"error": "role already exists"})
		return
	} else if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to create role: %v", err)})
		return
	}

	c.JSON(http.StatusCreated, role)
}

// CreatePermission создает новое право
// @Summary Создание права
// @Description Создает новое право в системе
// @Tags auth
// @Accept json
// @Produce json
// @Param permission body models.PermissionRequest true "Данные права"
// @Success 201 {object} models.SuccessPermission "Успешное создание права"
// @Failure 400 {object} models.ErrorResponse "Неверный ввод"
// @Failure 409 {object} models.ErrorResponse "Право уже существует"
// @Failure 500 {object} models.ErrorResponse "Внутренняя ошибка сервера"
// @Router /auth/permissions [post]
// @Security Bearer
func (h *AuthHandler) CreatePermission(c *gin.Context) {
	req, ok := middleware.GetRequest[models.PermissionRequest](c)
	if !ok {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid input"})
		return
	}

	// Передаём контекст из запроса
	permission, err := h.Service.CreatePermission(c.Request.Context(), req.Name, req.Description)
	if err == customerrors.ErrUserExists {
		c.JSON(http.StatusConflict, gin.H{"error": "permission already exists"})
		return
	} else if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to create permission: %v", err)})
		return
	}

	c.JSON(http.StatusCreated, permission)
}

// AssignRoleToUser назначает роль пользователю
// @Summary Назначение роли пользователю
// @Description Назначает указанную роль пользователю
// @Tags auth
// @Accept json
// @Produce json
// @Param assignment body models.RoleAssignmentRequest true "Данные назначения"
// @Success 200 {object} map[string]string "Успешное назначение роли"
// @Failure 400 {object} models.ErrorResponse "Неверный ввод"
// @Failure 404 {object} models.ErrorResponse "Пользователь или роль не найдены"
// @Failure 500 {object} models.ErrorResponse "Внутренняя ошибка сервера"
// @Router /auth/roles/assign [post]
// @Security Bearer
func (h *AuthHandler) AssignRoleToUser(c *gin.Context) {
	req, ok := middleware.GetRequest[models.RoleAssignmentRequest](c)
	if !ok {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid input"})
		return
	}

	// Передаём контекст из запроса
	err := h.Service.AssignRoleToUser(c.Request.Context(), req.UserID, req.RoleID)
	if err == customerrors.ErrUserNotFound {
		c.JSON(http.StatusNotFound, gin.H{"error": "user or role not found"})
		return
	} else if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to assign role: %v", err)})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "role assigned successfully"})
}

// AssignPermissionToRole назначает право роли
// @Summary Назначение права роли
// @Description Назначает указанное право роли
// @Tags auth
// @Accept json
// @Produce json
// @Param assignment body models.PermissionAssignmentRequest true "Данные назначения"
// @Success 200 {object} map[string]string "Успешное назначение права"
// @Failure 400 {object} models.ErrorResponse "Неверный ввод"
// @Failure 404 {object} models.ErrorResponse "Роль или право не найдены"
// @Failure 500 {object} models.ErrorResponse "Внутренняя ошибка сервера"
// @Router /auth/permissions/assign [post]
// @Security Bearer
func (h *AuthHandler) AssignPermissionToRole(c *gin.Context) {
	req, ok := middleware.GetRequest[models.PermissionAssignmentRequest](c)
	if !ok {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid input"})
		return
	}

	// Передаём контекст из запроса
	err := h.Service.AssignPermissionToRole(c.Request.Context(), req.RoleID, req.PermissionID)
	if err == customerrors.ErrUserNotFound {
		c.JSON(http.StatusNotFound, gin.H{"error": "role or permission not found"})
		return
	} else if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to assign permission: %v", err)})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "permission assigned successfully"})
}

// Refresh обновляет access-токен с помощью refresh-токена
// @Summary Обновление токена
// @Description Обновляет access-токен используя refresh-токен
// @Tags auth
// @Accept json
// @Produce json
// @Param refresh body models.RefreshRequest true "Refresh токен"
// @Success 200 {object} map[string]string "Успешное обновление токена"
// @Failure 400 {object} models.ErrorResponse "Неверный ввод"
// @Failure 401 {object} models.ErrorResponse "Неверный или истекший refresh-токен"
// @Failure 500 {object} models.ErrorResponse "Внутренняя ошибка сервера"
// @Router /auth/refresh [post]
// @Security Bearer
func (h *AuthHandler) Refresh(c *gin.Context) {
	req, ok := middleware.GetRequest[models.RefreshRequest](c)
	if !ok {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid input"})
		return
	}

	userID, err := h.Service.ValidateRefreshToken(req.RefreshToken)
	if err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid or expired refresh token"})
		return
	}

	userWithRole, err := h.Service.GetUserWithRoleByID(userID)
	if err != nil || userWithRole == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to fetch user"})
		return
	}
	if userWithRole.RoleID == nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "user role not assigned"})
		return
	}

	permissions, err := h.Service.GetRolePermissionsRecursive(*userWithRole.RoleID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to fetch permissions: %v", err)})
		return
	}

	accessToken, refreshToken, err := h.generateTokens(c.Request.Context(), userWithRole.ID, userWithRole.Role.Name, permissions)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"access_token":  accessToken,
		"refresh_token": refreshToken,
		"token_type":    "Bearer",
	})
}

// Logout отзывает refresh-токен пользователя
// @Summary Выход из системы
// @Description Отзывает refresh-токен, завершая сессию пользователя
// @Tags auth
// @Accept json
// @Produce json
// @Param refresh body models.RefreshRequest true "Refresh токен"
// @Success 200 {object} map[string]string "Успешный выход"
// @Failure 400 {object} models.ErrorResponse "Неверный ввод"
// @Failure 401 {object} models.ErrorResponse "Неверный refresh-токен"
// @Failure 500 {object} models.ErrorResponse "Внутренняя ошибка сервера"
// @Router /auth/logout [post]
// @Security Bearer
func (h *AuthHandler) Logout(c *gin.Context) {
	req, ok := middleware.GetRequest[models.RefreshRequest](c)
	if !ok {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid input"})
		return
	}

	err := h.Service.RevokeRefreshToken(c.Request.Context(), req.RefreshToken)
	if err == customerrors.ErrInvalidToken {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid refresh token"})
		return
	} else if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to revoke refresh token: %v", err)})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "successfully logged out"})
}

// GetProfile получает профиль пользователя
// @Summary Получение профиля
// @Description Получает профиль текущего пользователя
// @Tags profile
// @Produce json
// @Security Bearer
// @Success 200 {object} models.ProfileResponse "Успешное получение профиля"
// @Failure 401 {object} models.ErrorResponse "Неавторизован"
// @Failure 500 {object} models.ErrorResponse "Внутренняя ошибка сервера"
// @Router /profile [get]
func (h *AuthHandler) GetProfile(c *gin.Context) {
	userID, exists := middleware.GetUserID(c)                                    // Используем helper из middleware
	fmt.Printf("AuthHandler.GetProfile: userID=%d, exists=%v\n", userID, exists) // ADD THIS
	if !exists {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}

	profile, err := h.Service.GetProfile(userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to get profile: %v", err)})
		return
	}

	c.JSON(http.StatusOK, profile)
}

// UpdateProfile обновляет профиль пользователя
// @Summary Обновление профиля
// @Description Обновляет профиль текущего пользователя
// @Tags profile
// @Accept json
// @Produce json
// @Security Bearer
// @Param profile body models.UpdateProfileRequest true "Данные профиля"
// @Success 200 {object} models.ProfileResponse "Успешное обновление профиля"
// @Failure 400 {object} models.ErrorResponse "Неверный ввод"
// @Failure 401 {object} models.ErrorResponse "Неавторизован"
// @Failure 500 {object} models.ErrorResponse "Внутренняя ошибка сервера"
// @Router /profile [put]
func (h *AuthHandler) UpdateProfile(c *gin.Context) {
	userID := c.GetUint("user_id")
	if userID == 0 {
		c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
		return
	}

	req, ok := middleware.GetRequest[models.UpdateProfileRequest](c)
	if !ok {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid input"})
		return
	}

	if err := h.Service.UpdateProfile(c.Request.Context(), userID, &req); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to update profile: %v", err)})
		return
	}

	profile, err := h.Service.GetProfile(userID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to get updated profile: %v", err)})
		return
	}

	c.JSON(http.StatusOK, profile)
}

// InitiatePasswordReset инициирует процесс сброса пароля
// @Summary Инициация сброса пароля
// @Description Отправляет токен для сброса пароля на email пользователя
// @Tags auth
// @Accept json
// @Produce json
// @Param request body models.PasswordResetRequest true "Email пользователя"
// @Success 200 {object} map[string]string "Успешная инициация сброса"
// @Failure 400 {object} models.ErrorResponse "Неверный ввод"
// @Failure 500 {object} models.ErrorResponse "Внутренняя ошибка сервера"
// @Router /auth/password-reset [post]
func (h *AuthHandler) InitiatePasswordReset(c *gin.Context) {
	req, ok := middleware.GetRequest[models.PasswordResetRequest](c)
	if !ok {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid input"})
		return
	}

	if err := h.Service.InitiatePasswordReset(c.Request.Context(), req.Email); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to initiate password reset: %v", err)})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "if the email exists, a password reset link will be sent"})
}

// ResetPassword сбрасывает пароль пользователя
// @Summary Сброс пароля
// @Description Устанавливает новый пароль с использованием токена сброса
// @Tags auth
// @Accept json
// @Produce json
// @Param request body models.PasswordResetConfirm true "Токен и новый пароль"
// @Success 200 {object} map[string]string "Успешный сброс пароля"
// @Failure 400 {object} models.ErrorResponse "Неверный ввод"
// @Failure 401 {object} models.ErrorResponse "Неверный или истекший токен"
// @Failure 500 {object} models.ErrorResponse "Внутренняя ошибка сервера"
// @Router /auth/password-reset/confirm [post]
func (h *AuthHandler) ResetPassword(c *gin.Context) {
	req, ok := middleware.GetRequest[models.PasswordResetConfirm](c)
	if !ok {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid input"})
		return
	}

	if err := h.Service.ResetPassword(c.Request.Context(), req.Token, req.NewPassword); err != nil {
		if err == customerrors.ErrInvalidToken {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "invalid or expired token"})
			return
		}
		c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("failed to reset password: %v", err)})
		return
	}

	c.JSON(http.StatusOK, gin.H{"message": "password has been reset successfully"})
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\auth\middleware\bind_json.go
Содержимое: 
package middleware

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

// BindJSON middleware для валидации JSON-запросов и сохранения результата в контексте
func BindJSON[T any]() gin.HandlerFunc {
	return func(c *gin.Context) {
		var req T
		if err := c.ShouldBindJSON(&req); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "invalid input"})
			c.Abort()
			return
		}
		c.Set("request", req)
		c.Next()
	}
}

// GetRequest извлекает валидированный запрос из контекста
func GetRequest[T any](c *gin.Context) (T, bool) {
	req, exists := c.Get("request")
	if !exists {
		var zero T
		return zero, false
	}
	if r, ok := req.(T); ok {
		return r, true
	}
	var zero T
	return zero, false
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\auth\middleware\cors.go
Содержимое: 
package middleware

import (
	"backend/internal/config"

	"github.com/gin-gonic/gin"
)

// CORS middleware для обработки Cross-Origin Resource Sharing
func CORS(cfg *config.Config) gin.HandlerFunc {
	return func(c *gin.Context) {
		origin := c.Request.Header.Get("Origin")

		// Проверяем, разрешен ли данный origin
		allowedOrigin := "*"
		for _, allowed := range cfg.CORS.AllowOrigins {
			if allowed == origin {
				allowedOrigin = origin
				break
			}
		}

		c.Writer.Header().Set("Access-Control-Allow-Origin", allowedOrigin)

		if cfg.CORS.AllowCredentials {
			c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
		}

		c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
		c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE")
		c.Writer.Header().Set("Access-Control-Max-Age", cfg.CORS.MaxAge.String())

		if c.Request.Method == "OPTIONS" {
			c.AbortWithStatus(204)
			return
		}

		c.Next()
	}
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\auth\middleware\cors_test.go
Содержимое: 
package middleware

import (
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"backend/internal/config"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
)

func TestCORSMiddlewareBasic(t *testing.T) {
	gin.SetMode(gin.TestMode)
	router := gin.New()

	cfg := &config.Config{
		CORS: config.CORSConfig{
			AllowOrigins:     []string{"http://localhost:3000"},
			AllowCredentials: true,
			MaxAge:           time.Hour,
		},
	}

	router.Use(CORS(cfg))
	router.GET("/test", func(c *gin.Context) {
		c.Status(http.StatusOK)
	})

	w := httptest.NewRecorder()
	req, _ := http.NewRequest("GET", "/test", nil)
	req.Header.Set("Origin", "http://localhost:3000")
	router.ServeHTTP(w, req)

	assert.Equal(t, "http://localhost:3000", w.Header().Get("Access-Control-Allow-Origin"))
	assert.Equal(t, "true", w.Header().Get("Access-Control-Allow-Credentials"))
}

func TestCORSMiddlewareDetailed(t *testing.T) {
	gin.SetMode(gin.TestMode)

	tests := []struct {
		name           string
		method         string
		expectedCode   int
		expectedHeader map[string]string
	}{
		{
			name:         "Обычный запрос",
			method:       "GET",
			expectedCode: http.StatusOK,
			expectedHeader: map[string]string{
				"Access-Control-Allow-Origin":      "*",
				"Access-Control-Allow-Methods":     "POST, OPTIONS, GET, PUT, DELETE",
				"Access-Control-Allow-Headers":     "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With",
				"Access-Control-Allow-Credentials": "true",
			},
		},
		{
			name:         "Preflight запрос",
			method:       "OPTIONS",
			expectedCode: http.StatusNoContent,
			expectedHeader: map[string]string{
				"Access-Control-Allow-Origin":      "*",
				"Access-Control-Allow-Methods":     "POST, OPTIONS, GET, PUT, DELETE",
				"Access-Control-Allow-Headers":     "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With",
				"Access-Control-Allow-Credentials": "true",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			w := httptest.NewRecorder()
			_, r := gin.CreateTestContext(w)

			// Добавляем CORS middleware
			r.Use(CORS(&config.Config{
				CORS: config.CORSConfig{
					AllowCredentials: true,
					MaxAge:           time.Hour * 24,
				},
			}))
			r.GET("/test", func(c *gin.Context) {
				c.Status(http.StatusOK)
			})

			req := httptest.NewRequest(tt.method, "/test", nil)
			r.ServeHTTP(w, req)

			assert.Equal(t, tt.expectedCode, w.Code)

			// Проверяем заголовки CORS
			for key, value := range tt.expectedHeader {
				assert.Equal(t, value, w.Header().Get(key))
			}
		})
	}
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\auth\middleware\jwt.go
Содержимое: 
package middleware

import (
	"fmt"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
)

const (
	authorizationHeader = "Authorization"
	userIDKey           = "userID"
	roleKey             = "role"
	permissionsKey      = "permissions"
)

// JWTMiddleware проверяет JWT токен и добавляет userID, role и permissions в контекст
func JWTMiddleware(secretKey string, validateToken func(string, string) (uint, string, []string, error)) gin.HandlerFunc {
	return func(c *gin.Context) {
		header := c.GetHeader(authorizationHeader)
		fmt.Printf("JWTMiddleware called. Authorization header: %s\n", header)
		if header == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization header is required"})
			c.Abort()
			return
		}

		bearerToken := strings.Split(header, " ")
		if len(bearerToken) != 2 || bearerToken[0] != "Bearer" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token format"})
			c.Abort()
			return
		}

		userID, role, permissions, err := validateToken(bearerToken[1], secretKey)
		if err != nil || userID == 0 {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
			c.Abort()
			return
		}

		c.Set(userIDKey, userID)
		c.Set(roleKey, role)
		c.Set(permissionsKey, permissions)
		c.Next()
	}
}

// GetUserID получает ID пользователя из контекста
func GetUserID(c *gin.Context) (uint, bool) {
	id, exists := c.Get(userIDKey)
	if !exists {
		return 0, false
	}

	switch v := id.(type) {
	case float64:
		return uint(v), true
	case uint:
		return v, true
	default:
		return 0, false
	}
}

// GetRole получает роль из контекста
func GetRole(c *gin.Context) (string, bool) {
	role, exists := c.Get(roleKey)
	if !exists {
		return "", false
	}
	if r, ok := role.(string); ok {
		return r, true
	}
	return "", false
}

// GetPermissions получает права из контекста
func GetPermissions(c *gin.Context) ([]string, bool) {
	perms, exists := c.Get(permissionsKey)
	if !exists {
		return nil, false
	}
	if p, ok := perms.([]string); ok {
		return p, true
	}
	return nil, false
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\auth\middleware\jwt_test.go
Содержимое: 
package middleware

import (
	"net/http"
	"net/http/httptest"
	"testing"

	"backend/internal/utils"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
)

func TestJWTMiddleware(t *testing.T) {
	gin.SetMode(gin.TestMode)
	secretKey := "secret"

	router := gin.Default()
	// Передаем utils.ValidateToken как второй аргумент
	router.Use(JWTMiddleware(secretKey, utils.ValidateToken))
	router.GET("/protected", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"message": "success"})
	})

	t.Run("Успешная аутентификация", func(t *testing.T) {
		token, err := utils.GenerateToken(1, "user", []string{"read"}, secretKey)
		assert.NoError(t, err)

		req, _ := http.NewRequest("GET", "/protected", nil)
		req.Header.Set("Authorization", "Bearer "+token)
		w := httptest.NewRecorder()
		router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusOK, w.Code, "Expected status 200 OK")
		assert.Contains(t, w.Body.String(), "success")
	})

	t.Run("Отсутствует заголовок Authorization", func(t *testing.T) {
		req, _ := http.NewRequest("GET", "/protected", nil)
		w := httptest.NewRecorder()
		router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusUnauthorized, w.Code)
		assert.Contains(t, w.Body.String(), "Authorization header is required")
	})

	t.Run("Неверный формат токена", func(t *testing.T) {
		req, _ := http.NewRequest("GET", "/protected", nil)
		req.Header.Set("Authorization", "InvalidToken")
		w := httptest.NewRecorder()
		router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusUnauthorized, w.Code)
		assert.Contains(t, w.Body.String(), "Invalid token format")
	})

	t.Run("Неверный токен", func(t *testing.T) {
		token, _ := utils.GenerateToken(1, "user", []string{"read"}, "wrongsecret")
		req, _ := http.NewRequest("GET", "/protected", nil)
		req.Header.Set("Authorization", "Bearer "+token)
		w := httptest.NewRecorder()
		router.ServeHTTP(w, req)

		assert.Equal(t, http.StatusUnauthorized, w.Code)
		assert.Contains(t, w.Body.String(), "Invalid token")
	})
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\auth\middleware\logger.go
Содержимое: 
package middleware

import (
	"time"

	"backend/pkg/logger"

	"github.com/gin-gonic/gin"
)

// RequestLogger middleware для логирования HTTP запросов
func RequestLogger() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Время начала запроса
		start := time.Now()
		path := c.Request.URL.Path
		raw := c.Request.URL.RawQuery

		// Обработка запроса
		c.Next()

		// Время окончания запроса
		timestamp := time.Now()
		latency := timestamp.Sub(start)

		// Получение статуса ответа
		status := c.Writer.Status()

		if raw != "" {
			path = path + "?" + raw
		}

		// Логирование информации о запросе
		logger.Logger.Infof("[HTTP] %d | %13v | %15s | %s | %s",
			status,
			latency,
			c.ClientIP(),
			c.Request.Method,
			path,
		)
	}
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\auth\middleware\logger_test.go
Содержимое: 
package middleware

import (
	"bytes"
	"net/http"
	"net/http/httptest"
	"testing"

	"backend/pkg/logger"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
)

func TestRequestLogger(t *testing.T) {
	gin.SetMode(gin.TestMode)

	tests := []struct {
		name     string
		path     string
		method   string
		status   int
		expected []string
	}{
		{
			name:   "Успешный запрос",
			path:   "/test",
			method: "GET",
			status: http.StatusOK,
			expected: []string{
				"[HTTP]",
				"200",
				"GET",
				"/test",
			},
		},
		{
			name:   "Запрос с query параметрами",
			path:   "/test?param=value",
			method: "GET",
			status: http.StatusOK,
			expected: []string{
				"[HTTP]",
				"200",
				"GET",
				"/test?param=value",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Создаем буфер для логов
			var buf bytes.Buffer
			oldLogger := logger.Logger
			logger.Logger = logger.NewTestLogger(&buf)
			defer func() {
				logger.Logger = oldLogger
			}()

			w := httptest.NewRecorder()
			_, r := gin.CreateTestContext(w)

			r.Use(RequestLogger())
			r.GET("/test", func(c *gin.Context) {
				c.Status(tt.status)
			})

			req := httptest.NewRequest(tt.method, tt.path, nil)
			r.ServeHTTP(w, req)

			// Проверяем, что все ожидаемые строки есть в логе
			logOutput := buf.String()
			for _, expected := range tt.expected {
				assert.Contains(t, logOutput, expected, "Log should contain '%s'", expected)
			}
		})
	}
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\auth\middleware\rate_limiter.go
Содержимое: 
package middleware

import (
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"golang.org/x/time/rate"
)

// RateLimiter middleware для ограничения количества запросов
func RateLimiter(requests int, per time.Duration) gin.HandlerFunc {
	limiter := rate.NewLimiter(rate.Every(per/time.Duration(requests)), requests)
	return func(c *gin.Context) {
		if !limiter.Allow() {
			c.JSON(http.StatusTooManyRequests, gin.H{
				"error": "too many requests",
			})
			c.Abort()
			return
		}
		c.Next()
	}
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\auth\middleware\rbac.go
Содержимое: 
package middleware

import (
	"net/http"

	"backend/internal/auth/service"

	"github.com/gin-gonic/gin"
)

func RBAC(svc service.AuthServiceInterface, requiredPermission string) gin.HandlerFunc {
	return func(c *gin.Context) {
		// Проверяем только наличие userID, не сохраняя его
		if _, exists := GetUserID(c); !exists {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "user not authenticated"})
			c.Abort()
			return
		}

		role, roleExists := GetRole(c)
		if !roleExists || role == "" {
			c.JSON(http.StatusForbidden, gin.H{"error": "user has no role"})
			c.Abort()
			return
		}

		permissions, permsExist := GetPermissions(c)
		if !permsExist {
			c.JSON(http.StatusForbidden, gin.H{"error": "no permissions found"})
			c.Abort()
			return
		}

		hasPermission := false
		for _, perm := range permissions {
			if perm == requiredPermission {
				hasPermission = true
				break
			}
		}

		if !hasPermission {
			c.JSON(http.StatusForbidden, gin.H{"error": "access denied"})
			c.Abort()
			return
		}

		c.Next()
	}
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\auth\middleware\security.go
Содержимое: 
package middleware

import (
	"sync"

	"github.com/gin-gonic/gin"
	"golang.org/x/time/rate"
)

// Структура для хранения лимитеров
type IPRateLimiter struct {
	ips   map[string]*rate.Limiter
	mu    *sync.RWMutex
	rate  rate.Limit
	burst int
}

// Создание нового rate limiter'а
func NewIPRateLimiter(r rate.Limit, b int) *IPRateLimiter {
	return &IPRateLimiter{
		ips:   make(map[string]*rate.Limiter),
		mu:    &sync.RWMutex{},
		rate:  r,
		burst: b,
	}
}

// Получение лимитера для IP
func (i *IPRateLimiter) GetLimiter(ip string) *rate.Limiter {
	i.mu.Lock()
	defer i.mu.Unlock()

	limiter, exists := i.ips[ip]
	if !exists {
		limiter = rate.NewLimiter(i.rate, i.burst)
		i.ips[ip] = limiter
	}

	return limiter
}

// SecurityHeaders добавляет заголовки безопасности
func SecurityHeaders() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Защита от XSS
		c.Header("X-XSS-Protection", "1; mode=block")
		// Защита от кликджекинга
		c.Header("X-Frame-Options", "DENY")
		// Защита от MIME-сниффинга
		c.Header("X-Content-Type-Options", "nosniff")
		// Политика безопасности контента
		c.Header("Content-Security-Policy", "default-src 'self'; img-src 'self' https: data:; font-src 'self' https:; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline';")
		// HSTS (только для production)
		if gin.Mode() == gin.ReleaseMode {
			c.Header("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
		}
		// Отключение кеширования для API endpoints
		c.Header("Cache-Control", "no-store")
		c.Header("Pragma", "no-cache")

		c.Next()
	}
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\auth\middleware\security_test.go
Содержимое: 
package middleware

import (
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
)

func TestSecurityHeaders(t *testing.T) {
	gin.SetMode(gin.TestMode)

	tests := []struct {
		name           string
		expectedHeader map[string]string
	}{
		{
			name: "Проверка security заголовков",
			expectedHeader: map[string]string{
				"X-XSS-Protection":        "1; mode=block",
				"X-Frame-Options":         "DENY",
				"X-Content-Type-Options":  "nosniff",
				"Content-Security-Policy": "default-src 'self'; img-src 'self' https: data:; font-src 'self' https:; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline';",
				"Cache-Control":           "no-store",
				"Pragma":                  "no-cache",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			w := httptest.NewRecorder()
			_, r := gin.CreateTestContext(w)

			r.Use(SecurityHeaders())
			r.GET("/test", func(c *gin.Context) {
				c.Status(http.StatusOK)
			})

			req := httptest.NewRequest("GET", "/test", nil)
			r.ServeHTTP(w, req)

			for key, value := range tt.expectedHeader {
				assert.Equal(t, value, w.Header().Get(key))
			}
		})
	}
}

func TestRateLimiter(t *testing.T) {
	gin.SetMode(gin.TestMode)

	tests := []struct {
		name          string
		requests      int
		duration      time.Duration
		numRequests   int
		expectedCodes []int
	}{
		{
			name:          "В пределах лимита",
			requests:      2,
			duration:      time.Second,
			numRequests:   2,
			expectedCodes: []int{http.StatusOK, http.StatusOK},
		},
		{
			name:          "Превышение лимита",
			requests:      1,
			duration:      time.Second,
			numRequests:   2,
			expectedCodes: []int{http.StatusOK, http.StatusTooManyRequests},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			w := httptest.NewRecorder()
			_, r := gin.CreateTestContext(w)

			r.Use(RateLimiter(tt.requests, tt.duration))
			r.GET("/test", func(c *gin.Context) {
				c.Status(http.StatusOK)
			})

			for i := 0; i < tt.numRequests; i++ {
				w = httptest.NewRecorder()
				req := httptest.NewRequest("GET", "/test", nil)
				req.RemoteAddr = "127.0.0.1:12345" // Устанавливаем IP для rate limiter
				r.ServeHTTP(w, req)
				assert.Equal(t, tt.expectedCodes[i], w.Code)
			}
		})
	}
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\auth\middleware\trace.go
Содержимое: 
package middleware

import (
	"backend/pkg/logger"
	"context"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
)

// TraceMiddleware добавляет trace_id в контекст запроса
func TraceMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Проверяем, есть ли trace_id в заголовке X-Trace-ID (для совместимости с внешними системами)
		traceID := c.GetHeader("X-Trace-ID")
		if traceID == "" {
			// Если заголовок отсутствует, генерируем новый trace_id
			traceID = uuid.New().String()
		}

		// Добавляем trace_id в контекст для использования логгером
		ctx := context.WithValue(c.Request.Context(), logger.TraceIDKey, traceID)
		c.Request = c.Request.WithContext(ctx)

		// Добавляем trace_id в заголовок ответа для отладки
		c.Header("X-Trace-ID", traceID)

		// Переходим к следующему обработчику
		c.Next()
	}
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\auth\models\base.go
Содержимое: 
// internal/auth/models/base.go
package models

import (
	"time"
)

// BaseModel дублирует структуру gorm.Model для Swagger
type BaseModel struct {
	ID        uint       `json:"id" gorm:"primaryKey" swaggerignore:"true"`
	CreatedAt time.Time  `json:"created_at" swaggerignore:"true"`
	UpdatedAt time.Time  `json:"updated_at" swaggerignore:"true"`
	DeletedAt *time.Time `json:"deleted_at,omitempty" gorm:"index" swaggerignore:"true"`
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\auth\models\swagger_models.go
Содержимое: 
package models

// RoleRequest представляет запрос на создание роли
type RoleRequest struct {
	// Название роли
	// required: true
	// example: moderator
	Name string `json:"name" binding:"required" example:"moderator"`

	// Описание роли
	// example: Moderator with limited access
	Description string `json:"description" example:"Moderator with limited access"`
}

// PermissionRequest представляет запрос на создание права
type PermissionRequest struct {
	// Название права
	// required: true
	// example: delete
	Name string `json:"name" binding:"required" example:"delete"`

	// Описание права
	// example: Delete resources
	Description string `json:"description" example:"Delete resources"`
}

// RoleAssignmentRequest представляет запрос на назначение роли пользователю
type RoleAssignmentRequest struct {
	// ID пользователя
	// required: true
	// example: 1
	UserID uint `json:"user_id" binding:"required" example:"1"`

	// ID роли
	// required: true
	// example: 2
	RoleID uint `json:"role_id" binding:"required" example:"2"`
}

// PermissionAssignmentRequest представляет запрос на назначение права роли
type PermissionAssignmentRequest struct {
	// ID роли
	// required: true
	// example: 2
	RoleID uint `json:"role_id" binding:"required" example:"2"`

	// ID права
	// required: true
	// example: 1
	PermissionID uint `json:"permission_id" binding:"required" example:"1"`
}

type RegisterRequest struct {
	Email    string `json:"email" binding:"required,email" example:"user@example.com"`
	Password string `json:"password" binding:"required,min=8" example:"password123"`
	Name     string `json:"name" binding:"required" example:"John Doe"`
}

type LoginRequest struct {
	Email    string `json:"email" binding:"required,email" example:"user@example.com"`
	Password string `json:"password" binding:"required,min=8" example:"password123"`
}

type AuthResponse struct {
	Status  string `json:"status"`
	Message string `json:"message"`
	Token   string `json:"token,omitempty"`
}

type ErrorResponse struct {
	Status  string `json:"status"`
	Message string `json:"message"`
}

// SuccessRole структура для успешного ответа при создании роли
type SuccessRole struct {
	Message string `json:"message"`
	Role    Role   `json:"role"`
}

type SuccessPermission struct {
	Message    string `json:"message"`
	Permission string `json:"permission"`
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\auth\models\user.go
Содержимое: 
package models

import (
	"errors"
	"regexp"
	"strings"
	"time"
)

// User представляет пользователя системы
type User struct {
	BaseModel
	Email        string   `json:"email" gorm:"uniqueIndex;not null"`
	PasswordHash string   `json:"-" gorm:"not null"`
	RoleID       *uint    `json:"role_id" gorm:"column:role_id"`
	Role         *Role    `json:"role,omitempty" gorm:"foreignKey:RoleID"`
	Profile      *Profile `json:"profile,omitempty" gorm:"foreignKey:UserID"`
}

// Validate проверяет корректность данных пользователя
func (u *User) Validate() error {
	return u.ValidateEmail()
}

// ValidateEmail проверяет формат email
func (u *User) ValidateEmail() error {
	email := strings.TrimSpace(u.Email)
	emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
	if !emailRegex.MatchString(email) {
		return errors.New("invalid email format")
	}
	return nil
}

// Role представляет роль пользователя
// swagger:model Role
type Role struct {
	BaseModel
	Name        string `gorm:"uniqueIndex;not null" json:"name"`
	Description string `json:"description"`
	ParentID    *uint  `json:"parent_id,omitempty"`
	Parent      *Role  `gorm:"foreignKey:ParentID" json:"parent,omitempty"`
}

// Permission представляет разрешение в системе
type Permission struct {
	BaseModel
	Name        string `gorm:"uniqueIndex;not null"`
	Description string
}

// RolePermission связывает роли и разрешения
type RolePermission struct {
	BaseModel
	RoleID       uint `gorm:"uniqueIndex:idx_role_permission"`
	PermissionID uint `gorm:"uniqueIndex:idx_role_permission"`
}

// RefreshToken представляет refresh-токен для обновления сессии
type RefreshToken struct {
	BaseModel
	UserID    uint      `gorm:"index"`
	Token     string    `gorm:"uniqueIndex"`
	ExpiresAt time.Time `gorm:"index"`
}

// RefreshRequest структура для запроса обновления токена
type RefreshRequest struct {
	// Refresh токен
	// required: true
	// example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
	RefreshToken string `json:"refresh_token" binding:"required"`
}

// Profile представляет профиль пользователя
type Profile struct {
	BaseModel
	UserID      uint `gorm:"uniqueIndex;not null"`
	FirstName   string
	LastName    string
	Avatar      string
	PhoneNumber string
	Bio         string
}

// UpdateProfileRequest структура для обновления профиля
type UpdateProfileRequest struct {
	FirstName   string `json:"first_name"`
	LastName    string `json:"last_name"`
	PhoneNumber string `json:"phone_number"`
	Bio         string `json:"bio"`
}

// ProfileResponse структура для ответа с данными профиля
type ProfileResponse struct {
	ID          uint   `json:"id"`
	Email       string `json:"email"`
	FirstName   string `json:"first_name"`
	LastName    string `json:"last_name"`
	PhoneNumber string `json:"phone_number"`
	Bio         string `json:"bio"`
	Avatar      string `json:"avatar"`
	Role        string `json:"role"`
}

// PasswordResetRequest структура для запроса сброса пароля
type PasswordResetRequest struct {
	// Email пользователя
	// required: true
	// example: user@example.com
	Email string `json:"email" binding:"required,email"`
}

// PasswordResetConfirm структура для подтверждения сброса пароля
type PasswordResetConfirm struct {
	// Токен сброса пароля
	// required: true
	// example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
	Token string `json:"token" binding:"required"`

	// Новый пароль
	// required: true
	// example: newpassword123
	NewPassword string `json:"new_password" binding:"required,min=6"`
}

// PasswordReset представляет запись о сбросе пароля
type PasswordReset struct {
	BaseModel
	UserID    uint      `gorm:"not null"`
	Token     string    `gorm:"uniqueIndex;not null"`
	ExpiresAt time.Time `gorm:"not null"`
	Used      bool      `gorm:"default:false"`
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\auth\service\auth_service.go
Содержимое: 
package service

import (
	"context"
	"errors"
	"fmt"
	"log"
	"sync"
	"time"

	"github.com/golang-migrate/migrate/v4"
	_ "github.com/golang-migrate/migrate/v4/database/postgres"
	_ "github.com/golang-migrate/migrate/v4/source/file"
	"github.com/lib/pq"

	"backend/internal/auth/models"
	customerrors "backend/pkg/errors"
	"backend/pkg/logger"

	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
)

type AuthServiceInterface interface {
	RegisterUser(ctx context.Context, email, password string) error
	AuthenticateUser(email, password string) (*models.User, error)
	InitializeDatabase() error
	CreateRole(ctx context.Context, name, description string) (*models.Role, error)
	CreatePermission(ctx context.Context, name, description string) (*models.Permission, error)
	AssignRoleToUser(ctx context.Context, userID, roleID uint) error
	AssignPermissionToRole(ctx context.Context, roleID, permissionID uint) error
	GetUserWithRole(email string) (*models.User, error)
	GetUserWithRoleByID(userID uint) (*models.User, error)
	GenerateRefreshToken(ctx context.Context, userID uint) (string, error) // Обновлено
	ValidateRefreshToken(token string) (uint, error)
	RevokeRefreshToken(ctx context.Context, token string) error // Обновлено
	GetRolePermissionsRecursive(roleID uint) ([]string, error)
	GetProfile(userID uint) (*models.ProfileResponse, error)
	UpdateProfile(ctx context.Context, userID uint, update *models.UpdateProfileRequest) error // Обновлено
	UpdateAvatar(ctx context.Context, userID uint, avatarURL string) error                     // Обновлено
	InitiatePasswordReset(ctx context.Context, email string) error                             // Обновлено
	ValidateResetToken(token string) error
	ResetPassword(ctx context.Context, token string, newPassword string) error // Обновлено
	DB() DB
}

type DB interface {
	AutoMigrate(dst ...interface{}) error
	Create(value interface{}) *gorm.DB
	First(dst interface{}, conds ...interface{}) *gorm.DB
	Exec(sql string, vars ...interface{}) *gorm.DB
	Save(value interface{}) *gorm.DB
	Preload(query string, args ...interface{}) *gorm.DB
	Find(dest interface{}, conds ...interface{}) *gorm.DB
	Delete(value interface{}, conds ...interface{}) *gorm.DB
	FirstOrCreate(dst interface{}, conds ...interface{}) *gorm.DB
	Model(value interface{}) *gorm.DB
	Where(query interface{}, args ...interface{}) *gorm.DB
}

// TransactionRetrier интерфейс для выполнения транзакций с повторными попытками
type TransactionRetrier interface {
	WithTransactionRetry(ctx context.Context, fn func(tx *gorm.DB) error) error
}

type AuthService struct {
	db    DB
	dbRaw TransactionRetrier // Изменяем тип с *database.DB на интерфейс
	cache sync.Map
	dsn   string
}

type cachedPermissions struct {
	Permissions []string
	ExpiresAt   time.Time
}

type cachedProfile struct {
	Profile   *models.ProfileResponse
	ExpiresAt time.Time
}

const (
	cacheTTL = 5 * time.Minute
)

var _ AuthServiceInterface = (*AuthService)(nil)

// NewAuthService инициализирует сервис с кэшем и запускает очистку кэша
func NewAuthService(db DB, dbRaw TransactionRetrier, dsn string) AuthServiceInterface {
	s := &AuthService{
		db:    db,
		dbRaw: dbRaw,
		cache: sync.Map{},
		dsn:   dsn,
	}
	s.startCacheCleaner()
	return s
}

func (s *AuthService) DB() DB {
	return s.db
}

// startCacheCleaner запускает фоновую очистку устаревших записей кэша
func (s *AuthService) startCacheCleaner() {
	go func() {
		ticker := time.NewTicker(10 * time.Minute)
		defer ticker.Stop()
		for range ticker.C {
			s.cache.Range(func(key, value interface{}) bool {
				switch v := value.(type) {
				case cachedPermissions:
					if time.Now().After(v.ExpiresAt) {
						s.cache.Delete(key)
					}
				case cachedProfile:
					if time.Now().After(v.ExpiresAt) {
						s.cache.Delete(key)
					}
				}
				return true
			})
		}
	}()
}

func (s *AuthService) handleDBError(op string, err error) error {
	if err == nil {
		return nil
	}
	log.Printf("database error during %s: %v", op, err)
	switch {
	case errors.Is(err, gorm.ErrDuplicatedKey):
		return customerrors.ErrUserExists
	case errors.Is(err, gorm.ErrRecordNotFound):
		return customerrors.ErrUserNotFound
	default:
		if pqErr, ok := err.(*pq.Error); ok {
			if pqErr.Code == "40001" { // Serialization failure (deadlock)
				return err // Возвращаем оригинальную ошибку для обработки в WithTransactionRetry
			}
			return customerrors.ErrDatabaseConnection
		}
		return customerrors.ErrDatabaseConnection
	}
}

func (s *AuthService) hashPassword(password string) (string, error) {
	hashedBytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		log.Printf("failed to hash password: %v", err)
		return "", customerrors.ErrTokenCreation
	}
	return string(hashedBytes), nil
}

func (s *AuthService) comparePasswords(hashedPassword, password string) error {
	if err := bcrypt.CompareHashAndPassword([]byte(hashedPassword), []byte(password)); err != nil {
		log.Printf("password mismatch: %v", err)
		return customerrors.ErrInvalidCredentials
	}
	return nil
}

// InitializeDatabase инициализирует базу данных
func (s *AuthService) InitializeDatabase() error {
	logger.Logger.InfoNoCtx("Starting database initialization")

	if err := s.db.Exec("SELECT 1").Error; err != nil {
		logger.Logger.Errorf("Database connection check failed: %v", err)
		return fmt.Errorf("failed to verify database connection: %w", err)
	}

	migrationPath := "file://./migrations"
	logger.Logger.Infof("Initializing migrations with DSN: %s and path: %s", s.dsn, migrationPath)
	m, err := migrate.New(migrationPath, s.dsn)
	if err != nil {
		logger.Logger.Errorf("Failed to initialize migrations: %v", err)
		return fmt.Errorf("failed to initialize migrations: %w", err)
	}

	err = m.Up()
	if err != nil {
		if err == migrate.ErrNoChange {
			logger.Logger.Infof("No new migrations to apply")
		} else {
			logger.Logger.Errorf("Failed to apply migrations: %v", err)
			return fmt.Errorf("failed to apply migrations: %w", err)
		}
	}

	logger.Logger.InfoNoCtx("Database migrations applied successfully")

	if err := s.createAdminUserIfNotExists(); err != nil {
		logger.Logger.Errorf("Failed to create admin user: %v", err)
		return err
	}

	logger.Logger.InfoNoCtx("Database initialization completed successfully")
	return nil
}

func (s *AuthService) createAdminUserIfNotExists() error {
	// Используем context.Background(), так как это часть инициализации приложения
	return s.dbRaw.WithTransactionRetry(context.Background(), func(tx *gorm.DB) error {
		var user models.User
		if err := tx.First(&user, "email = ?", "admin@example.com").Error; err != nil {
			if !errors.Is(err, gorm.ErrRecordNotFound) {
				return s.handleDBError("find admin user", err)
			}

			hashedPassword, err := s.hashPassword("admin")
			if err != nil {
				return err
			}

			var adminRole models.Role
			if err := tx.First(&adminRole, "name = ?", "admin").Error; err != nil {
				if errors.Is(err, gorm.ErrRecordNotFound) {
					adminRole = models.Role{
						Name:        "admin",
						Description: "Administrator with full access",
					}
					if err := tx.Create(&adminRole).Error; err != nil {
						return s.handleDBError("create admin role", err)
					}
				} else {
					return s.handleDBError("find admin role", err)
				}
			}

			adminUser := &models.User{
				Email:        "admin@example.com",
				PasswordHash: hashedPassword,
				RoleID:       &adminRole.ID,
			}

			return s.handleDBError("create admin user", tx.Create(adminUser).Error)
		}
		return nil
	})
}

// RegisterUser регистрирует нового пользователя с использованием транзакции
func (s *AuthService) RegisterUser(ctx context.Context, email, password string) error {
	return s.dbRaw.WithTransactionRetry(ctx, func(tx *gorm.DB) error {
		var defaultRole models.Role
		if err := tx.First(&defaultRole, "name = ?", "user").Error; err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				logger.Logger.Infof("Role 'user' not found, creating new role")
				defaultRole = models.Role{
					Name:        "user",
					Description: "Default user role",
				}
				if err := tx.Create(&defaultRole).Error; err != nil {
					return s.handleDBError("create default user role", err)
				}
				logger.Logger.Infof("Role 'user' created successfully")
			} else {
				return s.handleDBError("find default user role", err)
			}
		} else {
			logger.Logger.Infof("Role 'user' found")
		}

		hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
		if err != nil {
			return fmt.Errorf("failed to hash password: %w", err)
		}

		user := models.User{
			Email:        email,
			PasswordHash: string(hashedPassword),
			RoleID:       &defaultRole.ID,
		}
		if err := tx.Create(&user).Error; err != nil {
			return s.handleDBError("create user", err)
		}
		logger.Logger.Infof("User created successfully")

		return nil
	})
}

func (s *AuthService) GetUserByEmail(email string) (*models.User, error) {
	var user models.User
	if err := s.db.First(&user, "email = ?", email).Error; err != nil {
		return nil, s.handleDBError("find user", err)
	}
	return &user, nil
}

// AuthenticateUser аутентифицирует пользователя (транзакция не требуется)
func (s *AuthService) AuthenticateUser(email, password string) (*models.User, error) {
	user := &models.User{}
	result := s.db.First(user, "email = ?", email)
	if result.Error != nil {
		if errors.Is(result.Error, gorm.ErrRecordNotFound) {
			return nil, customerrors.ErrUserNotFound
		}
		return nil, customerrors.ErrDatabaseConnection
	}

	if err := s.comparePasswords(user.PasswordHash, password); err != nil {
		return nil, err
	}

	return user, nil
}

// CreateRole создаёт роль
func (s *AuthService) CreateRole(ctx context.Context, name, description string) (*models.Role, error) {
	var role *models.Role
	err := s.dbRaw.WithTransactionRetry(ctx, func(tx *gorm.DB) error {
		role = &models.Role{
			Name:        name,
			Description: description,
		}
		if err := tx.Create(role).Error; err != nil {
			return s.handleDBError("create role", err)
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	return role, nil
}

// CreatePermission создаёт разрешение
func (s *AuthService) CreatePermission(ctx context.Context, name, description string) (*models.Permission, error) {
	var permission *models.Permission
	err := s.dbRaw.WithTransactionRetry(ctx, func(tx *gorm.DB) error {
		permission = &models.Permission{
			Name:        name,
			Description: description,
		}
		if err := tx.Create(permission).Error; err != nil {
			return s.handleDBError("create permission", err)
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	return permission, nil
}

// AssignRoleToUser назначает роль пользователю с использованием транзакции
func (s *AuthService) AssignRoleToUser(ctx context.Context, userID, roleID uint) error {
	return s.dbRaw.WithTransactionRetry(ctx, func(tx *gorm.DB) error {
		var user models.User
		if err := tx.First(&user, "id = ?", userID).Error; err != nil {
			return s.handleDBError("find user for role assignment", err)
		}

		var role models.Role
		if err := tx.First(&role, "id = ?", roleID).Error; err != nil {
			return s.handleDBError("find role for assignment", err)
		}

		user.RoleID = &roleID
		if err := tx.Save(&user).Error; err != nil {
			return s.handleDBError("assign role to user", err)
		}
		return nil
	})
}

// AssignPermissionToRole назначает разрешение роли с использованием транзакции
func (s *AuthService) AssignPermissionToRole(ctx context.Context, roleID, permissionID uint) error {
	return s.dbRaw.WithTransactionRetry(ctx, func(tx *gorm.DB) error {
		rolePermission := &models.RolePermission{
			RoleID:       roleID,
			PermissionID: permissionID,
		}
		if err := tx.Create(rolePermission).Error; err != nil {
			return s.handleDBError("assign permission to role", err)
		}
		return nil
	})
}

// GetUserWithRole получает пользователя с ролью
func (s *AuthService) GetUserWithRole(email string) (*models.User, error) {
	var user models.User
	if err := s.db.Preload("Role").First(&user, "email = ?", email).Error; err != nil {
		return nil, s.handleDBError("find user with role", err)
	}
	return &user, nil
}

func (s *AuthService) GetUserWithRoleByID(userID uint) (*models.User, error) {
	var user models.User
	if err := s.db.Preload("Role").First(&user, "id = ?", userID).Error; err != nil {
		return nil, s.handleDBError("find user with role by id", err)
	}
	return &user, nil
}

// GetRolePermissionsRecursive рекурсивно собирает все права роли, включая унаследованные, с использованием кэша
func (s *AuthService) GetRolePermissionsRecursive(roleID uint) ([]string, error) {
	cacheKey := fmt.Sprintf("role:%d", roleID)
	if cached, ok := s.cache.Load(cacheKey); ok {
		cachedPerms := cached.(cachedPermissions)
		if time.Now().Before(cachedPerms.ExpiresAt) {
			return cachedPerms.Permissions, nil
		}
		s.cache.Delete(cacheKey)
	}

	var permissions []string
	visited := make(map[uint]bool)

	var collectPermissions func(id uint) error
	collectPermissions = func(id uint) error {
		if visited[id] {
			return nil
		}
		visited[id] = true

		var rolePermissions []models.RolePermission
		if err := s.db.Find(&rolePermissions, "role_id = ?", id).Error; err != nil {
			return s.handleDBError("find role permissions", err)
		}

		for _, rp := range rolePermissions {
			var perm models.Permission
			if err := s.db.First(&perm, "id = ?", rp.PermissionID).Error; err == nil {
				permissions = append(permissions, perm.Name)
			}
		}

		var role models.Role
		if err := s.db.First(&role, "id = ?", id).Error; err != nil {
			return s.handleDBError("find role", err)
		}

		if role.ParentID != nil {
			if err := collectPermissions(*role.ParentID); err != nil {
				return err
			}
		}

		return nil
	}

	if err := collectPermissions(roleID); err != nil {
		return nil, err
	}

	uniquePermissions := make([]string, 0, len(permissions))
	seen := make(map[string]bool)
	for _, perm := range permissions {
		if !seen[perm] {
			seen[perm] = true
			uniquePermissions = append(uniquePermissions, perm)
		}
	}

	s.cache.Store(cacheKey, cachedPermissions{
		Permissions: uniquePermissions,
		ExpiresAt:   time.Now().Add(cacheTTL),
	})

	return uniquePermissions, nil
}

// GenerateRefreshToken генерирует новый refresh-токен с использованием транзакции
func (s *AuthService) GenerateRefreshToken(ctx context.Context, userID uint) (string, error) {
	var token string
	err := s.dbRaw.WithTransactionRetry(ctx, func(tx *gorm.DB) error {
		token = uuid.New().String()
		expiresAt := time.Now().Add(7 * 24 * time.Hour)

		refreshToken := &models.RefreshToken{
			UserID:    userID,
			Token:     token,
			ExpiresAt: expiresAt,
		}

		if err := tx.Create(refreshToken).Error; err != nil {
			return s.handleDBError("create refresh token", err)
		}
		return nil
	})
	if err != nil {
		return "", err
	}
	return token, nil
}

// ValidateRefreshToken проверяет refresh-токен и возвращает userID
func (s *AuthService) ValidateRefreshToken(token string) (uint, error) {
	var refreshToken models.RefreshToken
	_, err := s.validateToken(&refreshToken, token)
	if err != nil {
		return 0, err
	}
	return refreshToken.UserID, nil
}

// RevokeRefreshToken удаляет refresh-токен с использованием транзакции
func (s *AuthService) RevokeRefreshToken(ctx context.Context, token string) error {
	return s.dbRaw.WithTransactionRetry(ctx, func(tx *gorm.DB) error {
		if err := tx.Delete(&models.RefreshToken{}, "token = ?", token).Error; err != nil {
			return s.handleDBError("revoke refresh token", err)
		}
		return nil
	})
}

func (s *AuthService) GetProfile(userID uint) (*models.ProfileResponse, error) {
	cacheKey := fmt.Sprintf("profile:%d", userID)
	if cached, ok := s.cache.Load(cacheKey); ok {
		cachedProfile := cached.(cachedProfile)
		if time.Now().Before(cachedProfile.ExpiresAt) {
			return cachedProfile.Profile, nil
		}
		s.cache.Delete(cacheKey)
	}

	var user models.User
	if err := s.db.Preload("Role").Preload("Profile").First(&user, userID).Error; err != nil {
		return nil, s.handleDBError("get user profile", err)
	}

	response := &models.ProfileResponse{
		ID:    user.ID,
		Email: user.Email,
		Role:  user.Role.Name,
	}

	if user.Profile != nil {
		response.FirstName = user.Profile.FirstName
		response.LastName = user.Profile.LastName
		response.PhoneNumber = user.Profile.PhoneNumber
		response.Bio = user.Profile.Bio
		response.Avatar = user.Profile.Avatar
	}

	s.cache.Store(cacheKey, cachedProfile{
		Profile:   response,
		ExpiresAt: time.Now().Add(cacheTTL),
	})

	return response, nil
}

// UpdateProfile обновляет профиль пользователя с использованием транзакции
func (s *AuthService) UpdateProfile(ctx context.Context, userID uint, update *models.UpdateProfileRequest) error {
	return s.dbRaw.WithTransactionRetry(ctx, func(tx *gorm.DB) error {
		var profile models.Profile
		err := tx.FirstOrCreate(&profile, models.Profile{UserID: userID}).Error
		if err != nil {
			return s.handleDBError("get or create profile", err)
		}

		profile.FirstName = update.FirstName
		profile.LastName = update.LastName
		profile.PhoneNumber = update.PhoneNumber
		profile.Bio = update.Bio

		if err := tx.Save(&profile).Error; err != nil {
			return s.handleDBError("update profile", err)
		}

		// Очистка кэша после обновления
		cacheKey := fmt.Sprintf("profile:%d", userID)
		s.cache.Delete(cacheKey)

		return nil
	})
}

// UpdateAvatar обновляет аватар пользователя с использованием транзакции
func (s *AuthService) UpdateAvatar(ctx context.Context, userID uint, avatarURL string) error {
	return s.dbRaw.WithTransactionRetry(ctx, func(tx *gorm.DB) error {
		var profile models.Profile
		err := tx.FirstOrCreate(&profile, models.Profile{UserID: userID}).Error
		if err != nil {
			return s.handleDBError("get or create profile", err)
		}

		profile.Avatar = avatarURL
		if err := tx.Save(&profile).Error; err != nil {
			return s.handleDBError("update avatar", err)
		}

		// Очистка кэша после обновления
		cacheKey := fmt.Sprintf("profile:%d", userID)
		s.cache.Delete(cacheKey)

		return nil
	})
}

// InitiatePasswordReset инициирует процесс сброса пароля с использованием транзакции
func (s *AuthService) InitiatePasswordReset(ctx context.Context, email string) error {
	return s.dbRaw.WithTransactionRetry(ctx, func(tx *gorm.DB) error {
		var user models.User
		if err := tx.First(&user, "email = ?", email).Error; err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				return nil // Тихо игнорируем, если пользователь не найден
			}
			return s.handleDBError("find user for password reset", err)
		}

		token := uuid.New().String()
		expiresAt := time.Now().Add(1 * time.Hour)

		resetToken := &models.PasswordReset{
			UserID:    user.ID,
			Token:     token,
			ExpiresAt: expiresAt,
			Used:      false,
		}

		if err := tx.Create(resetToken).Error; err != nil {
			return s.handleDBError("create password reset token", err)
		}
		logger.Logger.Infof("Password reset initiated for user %s", email)
		return nil
	})
}

func (s *AuthService) ValidateResetToken(token string) error {
	var resetToken models.PasswordReset
	_, err := s.validateToken(&resetToken, token, "used = ?", false)
	if err != nil {
		return err
	}
	return nil
}

// ResetPassword сбрасывает пароль пользователя с использованием транзакции
func (s *AuthService) ResetPassword(ctx context.Context, token string, newPassword string) error {
	return s.dbRaw.WithTransactionRetry(ctx, func(tx *gorm.DB) error {
		var resetToken models.PasswordReset
		if err := tx.First(&resetToken, "token = ? AND used = false", token).Error; err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				return customerrors.ErrInvalidToken
			}
			return s.handleDBError("find reset token", err)
		}

		if time.Now().After(resetToken.ExpiresAt) {
			return customerrors.ErrInvalidToken
		}

		hashedPassword, err := s.hashPassword(newPassword)
		if err != nil {
			return err
		}

		if err := tx.Model(&models.User{}).Where("id = ?", resetToken.UserID).
			Update("password_hash", hashedPassword).Error; err != nil {
			return s.handleDBError("update password", err)
		}

		resetToken.Used = true
		if err := tx.Save(&resetToken).Error; err != nil {
			return s.handleDBError("mark token as used", err)
		}

		return nil
	})
}

// validateToken выполняет базовую проверку токена и возвращает срок действия и ошибку
func (s *AuthService) validateToken(table interface{}, token string, extraConditions ...interface{}) (time.Time, error) {
	query := s.db
	if len(extraConditions) > 0 {
		query = query.Where(extraConditions[0], extraConditions[1:]...)
	}
	if err := query.First(table, "token = ?", token).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return time.Time{}, customerrors.ErrInvalidToken
		}
		return time.Time{}, s.handleDBError("validate token", err)
	}

	// Предполагаем, что table имеет поле ExpiresAt
	switch t := table.(type) {
	case *models.RefreshToken:
		if time.Now().After(t.ExpiresAt) {
			return time.Time{}, customerrors.ErrInvalidToken
		}
		return t.ExpiresAt, nil
	case *models.PasswordReset:
		if time.Now().After(t.ExpiresAt) {
			return time.Time{}, customerrors.ErrInvalidToken
		}
		return t.ExpiresAt, nil
	default:
		return time.Time{}, fmt.Errorf("unsupported token type")
	}
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\auth\service\auth_service_test.go
Содержимое: 
package service

import (
	"context"
	"testing"
	"time"

	"backend/internal/config"
	"backend/internal/database"
	"backend/pkg/logger"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/lib/pq"
	"github.com/stretchr/testify/assert"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

// MockTransactionRetrier мок для TransactionRetrier
type MockTransactionRetrier struct {
	gormDB *gorm.DB
}

func (m *MockTransactionRetrier) WithTransactionRetry(ctx context.Context, fn func(tx *gorm.DB) error) error {
	cfg := &config.Config{
		Database: config.DatabaseConfig{
			MaxRetries: 3,
			RetryDelay: 1 * time.Second,
		},
	}

	for i := 0; i < cfg.Database.MaxRetries; i++ {
		tx := m.gormDB.WithContext(ctx).Begin()
		if tx.Error != nil {
			return tx.Error
		}

		err := fn(tx)
		if err != nil {
			tx.Rollback()
			if pqErr, ok := err.(*pq.Error); ok && pqErr.Code == "40001" {
				logger.Logger.Errorf("Deadlock detected in transaction: %s (Code: %s)", pqErr.Message, pqErr.Code)
				logger.Logger.Infof("Attempt %d/%d failed for transaction: %v", i+1, cfg.Database.MaxRetries, err)
				if i < cfg.Database.MaxRetries-1 {
					time.Sleep(cfg.Database.RetryDelay)
					continue
				}
				return err
			}
			return err
		}

		if err := tx.Commit().Error; err != nil {
			return err
		}
		return nil
	}
	return nil
}

func TestRegisterUser_DeadlockRetry(t *testing.T) {
	// Инициализация логгера
	err := logger.InitLogger("info", "console", "", 100, 10, 30, false, "UTC", "text")
	assert.NoError(t, err)

	// Создание mock базы данных
	sqlDB, sqlMock, err := sqlmock.New()
	assert.NoError(t, err)
	defer sqlDB.Close()

	// Создание GORM с моковой базой
	gormDB, err := gorm.Open(postgres.New(postgres.Config{
		Conn: sqlDB,
	}), &gorm.Config{})
	assert.NoError(t, err)

	// Создание моков
	mockDB := database.NewMockDB()
	mockRetrier := &MockTransactionRetrier{gormDB: gormDB}

	// Настройка AuthService
	authService := NewAuthService(mockDB, mockRetrier, "mock_dsn")

	// Настройка ожиданий для sqlMock (одна успешная попытка)
	sqlMock.ExpectBegin()
	sqlMock.ExpectQuery(`SELECT \* FROM "roles" WHERE name = \$1 ORDER BY "roles"."id" LIMIT \$2`).
		WithArgs("user", 1).
		WillReturnError(gorm.ErrRecordNotFound)
	sqlMock.ExpectQuery(`INSERT INTO "roles" \("created_at","updated_at","deleted_at","name","description","parent_id"\) VALUES \(\$1,\$2,\$3,\$4,\$5,\$6\) RETURNING "id"`).
		WithArgs(sqlmock.AnyArg(), sqlmock.AnyArg(), nil, "user", "Default user role", nil).
		WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))
	sqlMock.ExpectQuery(`INSERT INTO "users" \("created_at","updated_at","deleted_at","email","password_hash","role_id"\) VALUES \(\$1,\$2,\$3,\$4,\$5,\$6\) RETURNING "id"`).
		WithArgs(sqlmock.AnyArg(), sqlmock.AnyArg(), nil, "test@example.com", sqlmock.AnyArg(), 1).
		WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))
	sqlMock.ExpectCommit()

	// Выполнение теста
	ctx := context.Background()
	err = authService.RegisterUser(ctx, "test@example.com", "password123")
	assert.NoError(t, err)

	// Проверка ожиданий
	assert.NoError(t, sqlMock.ExpectationsWereMet())
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\config\config.go
Содержимое: 
package config

import (
	"fmt"
	"os"
	"reflect"
	"strconv"
	"strings"
	"time"

	"backend/pkg/logger"

	"github.com/go-playground/validator/v10"
	"github.com/joho/godotenv"
)

// Environment представляет окружение приложения
type Environment int

const (
	Development Environment = iota
	Production
	Testing
)

// String возвращает строковое представление Environment
func (e Environment) String() string {
	switch e {
	case Development:
		return "development"
	case Production:
		return "production"
	case Testing:
		return "testing"
	default:
		panic("unknown environment")
	}
}

// envVar представляет переменную окружения с значением по умолчанию
type envVar struct {
	key      string
	required bool
	default_ string
}

// getEnv получает значение переменной окружения
func getEnv(ev envVar) string {
	val := os.Getenv(ev.key)
	if val == "" {
		if ev.required {
			logger.Logger.Warnf("Required environment variable %s is not set", ev.key)
		}
		return ev.default_
	}
	return val
}

// CORSConfig содержит настройки CORS
type CORSConfig struct {
	AllowOrigins     []string
	AllowCredentials bool
	MaxAge           time.Duration
}

// RateLimitConfig содержит настройки для rate limiting
type RateLimitConfig struct {
	Requests int
	Period   time.Duration
	Enabled  bool
}

// DatabaseConfig содержит настройки базы данных
type DatabaseConfig struct {
	Host                 string `validate:"required"`
	Port                 int    `validate:"required,min=1,max=65535"`
	User                 string `validate:"required"`
	Password             string `validate:"required"`
	Name                 string `validate:"required"`
	SSLMode              string
	MaxOpenConns         int           `validate:"gte=1"`
	MaxIdleConns         int           `validate:"gte=0"`
	ConnMaxLifetime      time.Duration `validate:"gt=0"`
	ConnTimeout          time.Duration `validate:"gt=0"`
	MaxRetries           int           `validate:"gte=1"`
	RetryDelay           time.Duration `validate:"gte=100ms,lt=5s"`
	DeadlockLogLevel     string        `validate:"required,oneof=debug info warn error"` // Уровень логирования дедлоков
	TimeoutLogLevel      string        `validate:"required,oneof=debug info warn error"` // Уровень логирования таймаутов
	RetryAttemptLogLevel string        `validate:"required,oneof=debug info warn error"` // Уровень логирования попыток
}

// Config содержит все настройки приложения
type Config struct {
	Environment         Environment    `validate:"required"`
	Database            DatabaseConfig `validate:"required"`
	AppPort             string         `validate:"required,startswith=:"`
	JWTSecretKey        string         `validate:"required"`
	CSRFSecret          string         `validate:"required,gte=32"`
	CORS                CORSConfig
	RateLimit           RateLimitConfig
	SwaggerHost         string
	LogLevel            string `validate:"required,oneof=debug info warn error"`
	LogOutput           string `validate:"required,oneof=console file"`
	LogFilePath         string `validate:"required_if=LogOutput file"`
	LogRotateMaxSize    int    `validate:"gte=1"`
	LogRotateMaxBackups int    `validate:"gte=0"`
	LogRotateMaxAge     int    `validate:"gte=0"`
	LogRotateCompress   bool
	Timezone            string `validate:"required"`
	LogFormat           string `validate:"required,oneof=text json"`
}

// LoadConfig загружает конфигурацию из переменных окружения
func LoadConfig() (*Config, error) {
	env := getEnv(envVar{key: "ENVIRONMENT", default_: "development"})
	if err := godotenv.Load(fmt.Sprintf(".env%s", getEnvFileSuffix(env))); err != nil {
		logger.Logger.Warnf("Error loading %s file: %v", fmt.Sprintf(".env%s", getEnvFileSuffix(env)), err)
	}

	environment := parseEnvironment(env)
	dbConfig := loadDatabaseConfig()
	corsConfig := loadCORSConfig()
	rateLimitConfig, err := loadRateLimitConfig()
	if err != nil {
		return nil, err
	}

	timezone := getEnv(envVar{key: "TIMEZONE", required: true, default_: "UTC"})
	if _, err := time.LoadLocation(timezone); err != nil {
		return nil, fmt.Errorf("invalid timezone %s: %w", timezone, err)
	}

	cfg := &Config{
		Environment:         environment,
		Database:            dbConfig,
		AppPort:             normalizePort(getEnv(envVar{key: "APP_PORT", required: true})),
		JWTSecretKey:        getEnv(envVar{key: "JWT_SECRET_KEY", required: true}),
		CSRFSecret:          getEnv(envVar{key: "CSRF_SECRET", required: true}),
		CORS:                corsConfig,
		RateLimit:           *rateLimitConfig,
		SwaggerHost:         getEnv(envVar{key: "SWAGGER_HOST", required: true}),
		LogLevel:            getEnv(envVar{key: "LOG_LEVEL", required: true, default_: "info"}),
		LogOutput:           getEnv(envVar{key: "LOG_OUTPUT", required: true, default_: "console"}),
		LogFilePath:         getEnv(envVar{key: "LOG_FILE_PATH", default_: "./logs/app.log"}),
		LogRotateMaxSize:    parseIntWithDefault(getEnv(envVar{key: "LOG_ROTATE_MAX_SIZE", default_: "10"}), 10),
		LogRotateMaxBackups: parseIntWithDefault(getEnv(envVar{key: "LOG_ROTATE_MAX_BACKUPS", default_: "3"}), 3),
		LogRotateMaxAge:     parseIntWithDefault(getEnv(envVar{key: "LOG_ROTATE_MAX_AGE", default_: "7"}), 7),
		LogRotateCompress:   parseBoolWithDefault(getEnv(envVar{key: "LOG_ROTATE_COMPRESS", default_: "true"}), true),
		Timezone:            timezone,
		LogFormat:           getEnv(envVar{key: "LOG_FORMAT", required: true, default_: "text"}),
	}

	if err := cfg.validate(); err != nil {
		return nil, fmt.Errorf("config validation failed: %w", err)
	}

	return cfg, nil
}

// loadDatabaseConfig загружает конфигурацию базы данных
func loadDatabaseConfig() DatabaseConfig {
	connMaxLifetime, _ := time.ParseDuration(getEnv(envVar{key: "DB_CONN_MAX_LIFETIME", default_: "5m"}))
	connTimeout, _ := time.ParseDuration(getEnv(envVar{key: "DB_CONN_TIMEOUT", default_: "10s"}))
	retryDelay, _ := time.ParseDuration(getEnv(envVar{key: "DB_RETRY_DELAY", default_: "1s"}))

	return DatabaseConfig{
		Host:                 getEnv(envVar{key: "DB_HOST", required: true}),
		Port:                 parseIntWithDefault(getEnv(envVar{key: "DB_PORT", required: true}), 5432),
		User:                 getEnv(envVar{key: "DB_USER", required: true}),
		Password:             getEnv(envVar{key: "DB_PASSWORD", required: true}),
		Name:                 getEnv(envVar{key: "DB_NAME", required: true}),
		SSLMode:              getEnv(envVar{key: "DB_SSL_MODE", default_: "disable"}),
		MaxOpenConns:         parseIntWithDefault(getEnv(envVar{key: "DB_MAX_OPEN_CONNS", default_: "25"}), 25),
		MaxIdleConns:         parseIntWithDefault(getEnv(envVar{key: "DB_MAX_IDLE_CONNS", default_: "10"}), 10),
		ConnMaxLifetime:      connMaxLifetime,
		ConnTimeout:          connTimeout,
		MaxRetries:           parseIntWithDefault(getEnv(envVar{key: "DB_MAX_RETRIES", default_: "3"}), 3),
		RetryDelay:           retryDelay,
		DeadlockLogLevel:     getEnv(envVar{key: "DB_DEADLOCK_LOG_LEVEL", default_: "error"}),
		TimeoutLogLevel:      getEnv(envVar{key: "DB_TIMEOUT_LOG_LEVEL", default_: "warn"}),
		RetryAttemptLogLevel: getEnv(envVar{key: "DB_RETRY_ATTEMPT_LOG_LEVEL", default_: "warn"}),
	}
}

// loadCORSConfig загружает конфигурацию CORS
func loadCORSConfig() CORSConfig {
	origins := strings.Split(getEnv(envVar{key: "CORS_ORIGINS", required: true}), ",")

	maxAgeStr := getEnv(envVar{key: "CORS_MAX_AGE", required: true})
	maxAge, err := time.ParseDuration(maxAgeStr)
	if err != nil {
		logger.Logger.Warnf("Invalid CORS_MAX_AGE format: %v, using default 1h", err)
		maxAge = 1 * time.Hour
	}

	allowCredentials := parseBoolWithDefault(getEnv(envVar{key: "CORS_ALLOW_CREDENTIALS", default_: "true"}), true)

	return CORSConfig{
		AllowOrigins:     origins,
		AllowCredentials: allowCredentials,
		MaxAge:           maxAge,
	}
}

// loadRateLimitConfig загружает конфигурацию Rate Limiting
func loadRateLimitConfig() (*RateLimitConfig, error) {
	periodStr := getEnv(envVar{key: "RATE_LIMIT_PERIOD", required: true})
	period, err := time.ParseDuration(periodStr)
	if err != nil {
		logger.Logger.Warnf("Invalid RATE_LIMIT_PERIOD format: %v, using default 10m", err)
		period = 10 * time.Minute
	}

	enabled := parseBoolWithDefault(getEnv(envVar{key: "RATE_LIMIT_ENABLED", default_: "false"}), false)
	requests := parseIntWithDefault(getEnv(envVar{key: "RATE_LIMIT_REQUESTS", required: true}), 500)

	return &RateLimitConfig{
		Period:   period,
		Requests: requests,
		Enabled:  enabled,
	}, nil
}

// GetDSN возвращает строку подключения к базе данных для GORM
func (c *Config) GetDSN() string {
	sslMode := c.Database.SSLMode
	if sslMode == "" {
		sslMode = "disable"
	}

	return fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s timezone=%s",
		c.Database.Host, c.Database.Port, c.Database.User,
		c.Database.Password, c.Database.Name, sslMode, c.Timezone)
}

// GetMigrationDSN возвращает строку подключения в формате URL для миграций
func (c *Config) GetMigrationDSN() string {
	sslMode := c.Database.SSLMode
	if sslMode == "" {
		sslMode = "disable"
	}

	return fmt.Sprintf("postgres://%s:%s@%s:%d/%s?sslmode=%s&timezone=%s",
		c.Database.User, c.Database.Password, c.Database.Host,
		c.Database.Port, c.Database.Name, sslMode, c.Timezone)
}

// Вспомогательные функции

func getEnvFileSuffix(env string) string {
	if env == "development" {
		return ""
	}
	return "." + env
}

func normalizePort(port string) string {
	if port == "" {
		return ":8080"
	}
	if !strings.HasPrefix(port, ":") {
		return ":" + port
	}
	return port
}

func parseBoolWithDefault(s string, defaultVal bool) bool {
	if s == "" {
		return defaultVal
	}
	b, err := strconv.ParseBool(s)
	if err != nil {
		logger.Logger.Warnf("Failed to parse boolean: %s, using default value: %v", s, defaultVal)
		return defaultVal
	}
	return b
}

func parseIntWithDefault(s string, defaultVal int) int {
	if s == "" {
		return defaultVal
	}
	i, err := strconv.Atoi(s)
	if err != nil {
		logger.Logger.Warnf("Failed to parse integer: %s, using default value: %d", s, defaultVal)
		return defaultVal
	}
	return i
}

func parseEnvironment(env string) Environment {
	switch strings.ToLower(env) {
	case "production":
		return Production
	case "testing":
		return Testing
	default:
		return Development
	}
}

// validate проверяет корректность конфигурации
func (c *Config) validate() error {
	validate := validator.New()

	// Регистрируем кастомный валидатор для Environment
	validate.RegisterCustomTypeFunc(func(field reflect.Value) interface{} {
		if value, ok := field.Interface().(Environment); ok {
			return value.String()
		}
		return nil
	}, Environment(0))

	if err := validate.Struct(c); err != nil {
		return err
	}
	return nil
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\config\config_test.go
Содержимое: 
package config

import (
	"os"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

func TestLoadConfig(t *testing.T) {
	tests := []struct {
		name         string
		envVars      map[string]string
		expectedPort string
		expectedEnv  Environment
		expectedCORS CORSConfig
		expectError  bool
	}{
		{
			name: "Неверный формат RATE_LIMIT_PERIOD",
			envVars: map[string]string{
				"ENVIRONMENT":       "development",
				"APP_PORT":          ":8080",
				"RATE_LIMIT_PERIOD": "invalid",
				"DB_HOST":           "localhost",
				"DB_PORT":           "5432",
				"DB_USER":           "postgres",
				"DB_PASSWORD":       "postgres",
				"DB_NAME":           "dtt",
				"JWT_SECRET_KEY":    "secret",
				"RATE_LIMIT_REQ":    "100",
			},
			expectedPort: ":8080",
			expectedEnv:  Development,
			expectedCORS: CORSConfig{
				AllowOrigins:     []string{"http://localhost:3000"},
				AllowCredentials: true,
				MaxAge:           time.Hour,
			},
			expectError: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Очищаем все переменные окружения перед тестом
			for _, key := range []string{
				"ENVIRONMENT", "APP_PORT", "RATE_LIMIT_PERIOD",
				"DB_HOST", "DB_PORT", "DB_USER", "DB_PASSWORD",
				"DB_NAME", "JWT_SECRET_KEY", "RATE_LIMIT_REQ",
			} {
				os.Unsetenv(key)
			}

			// Устанавливаем тестовые переменные окружения
			for k, v := range tt.envVars {
				os.Setenv(k, v)
			}

			// Восстанавливаем переменные окружения после теста
			defer func() {
				for k := range tt.envVars {
					os.Unsetenv(k)
				}
			}()

			_, err := LoadConfig()
			if tt.expectError {
				assert.Error(t, err)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}

func TestEnvironmentString(t *testing.T) {
	tests := []struct {
		name        string
		env         Environment
		expected    string
		shouldPanic bool
	}{
		{
			name:     "Development",
			env:      Development,
			expected: "development",
		},
		{
			name:     "Production",
			env:      Production,
			expected: "production",
		},
		{
			name:     "Testing",
			env:      Testing,
			expected: "testing",
		},
		{
			name:        "Неизвестное окружение",
			env:         Environment(999),
			shouldPanic: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.shouldPanic {
				assert.Panics(t, func() {
					_ = tt.env.String()
				})
			} else {
				assert.Equal(t, tt.expected, tt.env.String())
			}
		})
	}
}

func TestGetDSN(t *testing.T) {
	tests := []struct {
		name     string
		config   Config
		expected string
	}{
		{
			name: "Development DSN",
			config: Config{
				Environment: Development,
				Database: DatabaseConfig{
					Host:     "localhost",
					Port:     5432,
					User:     "postgres",
					Password: "password",
					Name:     "dtt",
				},
			},
			expected: "host=localhost port=5432 user=postgres password=password dbname=dtt sslmode=disable",
		},
		{
			name: "Production DSN",
			config: Config{
				Environment: Production,
				Database: DatabaseConfig{
					Host:     "db.production.com",
					Port:     5432,
					User:     "app",
					Password: "secret",
					Name:     "dtt_prod",
				},
			},
			expected: "host=db.production.com port=5432 user=app password=secret dbname=dtt_prod sslmode=require",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			dsn := tt.config.GetDSN()
			assert.Equal(t, tt.expected, dsn)
		})
	}
}

func getRateLimitConfig(env Environment) RateLimitConfig {
	switch env {
	case Production:
		return RateLimitConfig{
			Requests: 100,
			Period:   time.Minute,
		}
	default:
		return RateLimitConfig{
			Requests: 1000,
			Period:   time.Minute,
		}
	}
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\database\database.go
Содержимое: 
package database

import (
	"context"
	"database/sql"
	"fmt"
	"time"

	"backend/internal/config"
	"backend/pkg/health"
	"backend/pkg/logger"
	"backend/pkg/metrics"

	"github.com/lib/pq"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

// GormDB интерфейс для работы с базой данных
type GormDB interface {
	AutoMigrate(dst ...interface{}) error
	Create(value interface{}) *gorm.DB
	First(dst interface{}, conds ...interface{}) *gorm.DB
	Exec(sql string, vars ...interface{}) *gorm.DB
	Save(value interface{}) *gorm.DB
	Preload(query string, args ...interface{}) *gorm.DB
	Find(dest interface{}, conds ...interface{}) *gorm.DB
	Delete(value interface{}, conds ...interface{}) *gorm.DB
	FirstOrCreate(dst interface{}, conds ...interface{}) *gorm.DB
	Model(value interface{}) *gorm.DB
	Where(query interface{}, args ...interface{}) *gorm.DB
}

// DB структура для работы с базой данных
type DB struct {
	Client GormDB
	sqlDB  *sql.DB
	config *config.Config
}

// Ensure DB implements health.PingableDB
var _ health.PingableDB = (*DB)(nil)

// logWithLevel логирует сообщение с заданным уровнем
func (db *DB) logWithLevel(level, msg string, args ...interface{}) {
	switch level {
	case "debug":
		logger.Logger.Debugf(msg, args...)
	case "info":
		logger.Logger.Infof(msg, args...)
	case "warn":
		logger.Logger.Warnf(msg, args...)
	case "error":
		logger.Logger.Errorf(msg, args...)
	default:
		newArgs := make([]interface{}, 0, len(args)+1)
		newArgs = append(newArgs, level)
		newArgs = append(newArgs, args...)
		logger.Logger.Warnf("Unknown log level %s, defaulting to warn: "+msg, newArgs...)
	}
}

// retry выполняет операцию с повторными попытками
func (db *DB) retry(operation string, attempts int, delay time.Duration, fn func() error) error {
	var err error
	for i := 0; i < attempts; i++ {
		err = fn()
		if err == nil {
			return nil
		}

		switch {
		case err == context.DeadlineExceeded:
			metrics.DatabaseSpecificErrors.WithLabelValues("timeout").Inc()
			db.logWithLevel(db.config.Database.TimeoutLogLevel, "Context timeout in %s after %v: %v", operation, delay*time.Duration(i), err)
		default:
			if pqErr, ok := err.(*pq.Error); ok {
				switch pqErr.Code {
				case "40001": // Serialization failure (deadlock)
					metrics.DatabaseSpecificErrors.WithLabelValues("deadlock").Inc()
					db.logWithLevel(db.config.Database.DeadlockLogLevel, "Deadlock detected in %s: %s (Code: %s)", operation, pqErr.Message, pqErr.Code)
				case "57014": // Query canceled (timeout)
					metrics.DatabaseSpecificErrors.WithLabelValues("timeout").Inc()
					db.logWithLevel(db.config.Database.TimeoutLogLevel, "Query timeout in %s: %s (Code: %s)", operation, pqErr.Message, pqErr.Code)
				}
			}
		}

		db.logWithLevel(db.config.Database.RetryAttemptLogLevel, "Attempt %d/%d failed for %s: %v", i+1, attempts, operation, err)
		metrics.DatabaseErrors.WithLabelValues(operation).Inc()
		if i < attempts-1 {
			time.Sleep(delay)
		}
	}
	return fmt.Errorf("failed after %d attempts for %s: %w", attempts, operation, err)
}

// WithTransactionRetry выполняет транзакцию с повторными попытками
func (db *DB) WithTransactionRetry(ctx context.Context, fn func(tx *gorm.DB) error) error {
	return db.retry("transaction", db.config.Database.MaxRetries, db.config.Database.RetryDelay, func() error {
		tx := db.Client.(*gorm.DB).WithContext(ctx).Begin()
		if tx.Error != nil {
			return fmt.Errorf("failed to begin transaction: %w", tx.Error)
		}

		defer func() {
			if r := recover(); r != nil {
				tx.Rollback()
				panic(r)
			}
		}()

		if err := fn(tx); err != nil {
			tx.Rollback()
			return err
		}

		if err := tx.Commit().Error; err != nil {
			return fmt.Errorf("failed to commit transaction: %w", err)
		}

		return nil
	})
}

// updatePoolMetrics обновляет метрики пула соединений
func (db *DB) updatePoolMetrics() {
	if db.sqlDB != nil {
		stats := db.sqlDB.Stats()
		metrics.DBOpenConnections.Set(float64(stats.OpenConnections))
		metrics.DBIdleConnections.Set(float64(stats.Idle))
		metrics.DBMaxOpenConnections.Set(float64(stats.MaxOpenConnections))
	}
}

// StartMonitoring запускает фоновый мониторинг состояния пула соединений
func (db *DB) StartMonitoring(ctx context.Context, interval time.Duration) {
	go func() {
		ticker := time.NewTicker(interval)
		defer ticker.Stop()

		for {
			select {
			case <-ctx.Done():
				logger.Logger.InfoNoCtx("Database pool monitoring stopped")
				return
			case <-ticker.C:
				db.updatePoolMetrics()
				logger.Logger.Debugf("Updated database pool metrics: open=%d, idle=%d, max=%d",
					db.sqlDB.Stats().OpenConnections,
					db.sqlDB.Stats().Idle,
					db.sqlDB.Stats().MaxOpenConnections)
			}
		}
	}()
}

// ConnectDB устанавливает соединение с базой данных
func ConnectDB(cfg *config.Config) (*DB, error) {
	dsn := cfg.GetDSN()
	logger.Logger.Infof("Connecting to database with DSN: %s", dsn)

	var db *gorm.DB
	err := (&DB{config: cfg}).retry("connect", cfg.Database.MaxRetries, cfg.Database.RetryDelay, func() error {
		start := time.Now()
		var connectErr error
		db, connectErr = gorm.Open(postgres.New(postgres.Config{
			DSN:                  dsn,
			PreferSimpleProtocol: true,
		}), &gorm.Config{
			DisableForeignKeyConstraintWhenMigrating: true,
		})
		duration := time.Since(start).Seconds()
		status := "success"
		if connectErr != nil {
			status = "error"
		}
		metrics.DatabaseQueriesTotal.WithLabelValues("connect", status).Inc()
		logger.Logger.Debugf("Database connection attempt took %f seconds", duration)
		return connectErr
	})
	if err != nil {
		return nil, fmt.Errorf("failed to connect to database: %w", err)
	}

	sqlDB, err := db.DB()
	if err != nil {
		return nil, fmt.Errorf("failed to get sql.DB: %w", err)
	}

	sqlDB.SetMaxOpenConns(cfg.Database.MaxOpenConns)
	sqlDB.SetMaxIdleConns(cfg.Database.MaxIdleConns)
	sqlDB.SetConnMaxLifetime(cfg.Database.ConnMaxLifetime)

	ctx, cancel := context.WithTimeout(context.Background(), cfg.Database.ConnTimeout)
	defer cancel()
	err = (&DB{config: cfg}).retry("ping", cfg.Database.MaxRetries, cfg.Database.RetryDelay, func() error {
		start := time.Now()
		pingErr := sqlDB.PingContext(ctx)
		duration := time.Since(start).Seconds()
		status := "success"
		if pingErr != nil {
			status = "error"
		}
		metrics.DatabaseQueriesTotal.WithLabelValues("ping", status).Inc()
		logger.Logger.Debugf("Database ping attempt took %f seconds", duration)
		return pingErr
	})
	if err != nil {
		return nil, fmt.Errorf("failed to ping database: %w", err)
	}

	dbInstance := &DB{Client: db, sqlDB: sqlDB, config: cfg}
	dbInstance.updatePoolMetrics()

	logger.Logger.InfoNoCtx(fmt.Sprintf(
		"Database connected with maxOpenConns=%d, maxIdleConns=%d, connMaxLifetime=%s, connTimeout=%s, maxRetries=%d, retryDelay=%s",
		cfg.Database.MaxOpenConns, cfg.Database.MaxIdleConns, cfg.Database.ConnMaxLifetime, cfg.Database.ConnTimeout, cfg.Database.MaxRetries, cfg.Database.RetryDelay,
	))

	return dbInstance, nil
}

// Close закрывает соединение с базой данных
func (db *DB) Close() error {
	if db.sqlDB != nil {
		return db.sqlDB.Close()
	}
	return nil
}

// Ping проверяет соединение с базой данных
func (db *DB) Ping() error {
	if db.sqlDB != nil {
		err := db.retry("ping", 3, 1*time.Second, func() error {
			start := time.Now()
			err := db.sqlDB.Ping()
			duration := time.Since(start).Seconds()
			status := "success"
			if err != nil {
				status = "error"
			}
			metrics.DatabaseQueriesTotal.WithLabelValues("ping", status).Inc()
			logger.Logger.Debugf("Database ping attempt took %f seconds with status=%s", duration, status)
			return err
		})
		db.updatePoolMetrics()
		return err
	}
	if mockDB, ok := db.Client.(*MockDB); ok {
		return mockDB.Ping()
	}
	return fmt.Errorf("unknown database type")
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\database\mock.go
Содержимое: 
package database

import (
	"backend/pkg/health"

	"github.com/stretchr/testify/mock"
	"gorm.io/gorm"
)

// MockDB мок для базы данных
type MockDB struct {
	mock.Mock
}

// Ensure MockDB implements GormDB and PingableDB
var _ GormDB = (*MockDB)(nil)
var _ health.PingableDB = (*MockDB)(nil) // Уточняем пространство имен

// NewMockDB создает новый мок базы данных
func NewMockDB() *MockDB {
	return &MockDB{}
}

// Ping реализует PingableDB
func (m *MockDB) Ping() error {
	args := m.Called()
	return args.Error(0)
}

// AutoMigrate реализует GormDB
func (m *MockDB) AutoMigrate(dst ...interface{}) error {
	args := m.Called(dst...)
	return args.Error(0)
}

// Create реализует GormDB
func (m *MockDB) Create(value interface{}) *gorm.DB {
	args := m.Called(value)
	if db, ok := args.Get(0).(*gorm.DB); ok {
		return db
	}
	return &gorm.DB{Error: args.Error(0)}
}

// First реализует GormDB
func (m *MockDB) First(dst interface{}, conds ...interface{}) *gorm.DB {
	args := m.Called(append([]interface{}{dst}, conds...)...)
	if db, ok := args.Get(0).(*gorm.DB); ok {
		return db
	}
	return &gorm.DB{Error: args.Error(0)}
}

// Exec реализует GormDB
func (m *MockDB) Exec(sql string, vars ...interface{}) *gorm.DB {
	args := m.Called(append([]interface{}{sql}, vars...)...)
	if db, ok := args.Get(0).(*gorm.DB); ok {
		return db
	}
	return &gorm.DB{Error: args.Error(0)}
}

// Save реализует GormDB
func (m *MockDB) Save(value interface{}) *gorm.DB {
	args := m.Called(value)
	if db, ok := args.Get(0).(*gorm.DB); ok {
		return db
	}
	return &gorm.DB{Error: args.Error(0)}
}

// Preload реализует GormDB
func (m *MockDB) Preload(query string, args ...interface{}) *gorm.DB {
	argsCalled := m.Called(append([]interface{}{query}, args...)...)
	if db, ok := argsCalled.Get(0).(*gorm.DB); ok {
		return db
	}
	return &gorm.DB{Error: argsCalled.Error(0)}
}

// Find реализует GormDB
func (m *MockDB) Find(dest interface{}, conds ...interface{}) *gorm.DB {
	args := m.Called(append([]interface{}{dest}, conds...)...)
	if db, ok := args.Get(0).(*gorm.DB); ok {
		return db
	}
	return &gorm.DB{Error: args.Error(0)}
}

// Delete реализует GormDB
func (m *MockDB) Delete(value interface{}, conds ...interface{}) *gorm.DB {
	args := m.Called(append([]interface{}{value}, conds...)...)
	if db, ok := args.Get(0).(*gorm.DB); ok {
		return db
	}
	return &gorm.DB{Error: args.Error(0)}
}

// FirstOrCreate реализует GormDB
func (m *MockDB) FirstOrCreate(dst interface{}, conds ...interface{}) *gorm.DB {
	args := m.Called(append([]interface{}{dst}, conds...)...)
	if db, ok := args.Get(0).(*gorm.DB); ok {
		return db
	}
	return &gorm.DB{Error: args.Error(0)}
}

// Model реализует GormDB
func (m *MockDB) Model(value interface{}) *gorm.DB {
	args := m.Called(value)
	if db, ok := args.Get(0).(*gorm.DB); ok {
		return db
	}
	return &gorm.DB{Error: args.Error(0)}
}

// Where реализует GormDB
func (m *MockDB) Where(query interface{}, args ...interface{}) *gorm.DB {
	argsCalled := m.Called(append([]interface{}{query}, args...)...)
	if db, ok := argsCalled.Get(0).(*gorm.DB); ok {
		return db
	}
	return &gorm.DB{Error: argsCalled.Error(0)}
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\utils\token.go
Содержимое: 
package utils

import (
	"fmt"
	"time"

	"github.com/golang-jwt/jwt/v5"
)

type Claims struct {
	UserID      uint     `json:"user_id"`
	Role        string   `json:"role"`        // Название роли
	Permissions []string `json:"permissions"` // Список прав
	jwt.RegisteredClaims
}

// GenerateToken создает новый JWT токен
func GenerateToken(userID uint, role string, permissions []string, secretKey string) (string, error) {
	claims := Claims{
		UserID:      userID,
		Role:        role,
		Permissions: permissions,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	return token.SignedString([]byte(secretKey))
}

// ValidateToken проверяет JWT токен и возвращает ID пользователя, роль и права
func ValidateToken(tokenString, secretKey string) (uint, string, []string, error) {
	fmt.Printf("ValidateToken called. Token string: %s\n", tokenString)

	token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
		return []byte(secretKey), nil
	})
	if err != nil {
		fmt.Printf("ValidateToken: Error parsing token: %v\n", err) // ADD THIS
		return 0, "", nil, err
	}

	claims, ok := token.Claims.(*Claims)
	if !ok || !token.Valid {
		fmt.Printf("ValidateToken: Invalid claims or token\n") // ADD THIS
		return 0, "", nil, jwt.ErrSignatureInvalid
	}

	fmt.Printf("ValidateToken: UserID=%d, Role=%s, Permissions=%v\n", claims.UserID, claims.Role, claims.Permissions) // ADD THIS

	return claims.UserID, claims.Role, claims.Permissions, nil
}

// GenerateTokenForTest создает тестовый токен и возвращает ошибку, если генерация не удалась
func GenerateTokenForTest(userID uint, role string, permissions []string, secretKey string) (string, error) {
	token, err := GenerateToken(userID, role, permissions, secretKey)
	if err != nil {
		return "", fmt.Errorf("failed to generate test token: %w", err)
	}
	return token, nil
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\internal\utils\token_test.go
Содержимое: 
package utils

import (
	"testing"
	"time"

	"github.com/golang-jwt/jwt/v5"
)

func TestGenerateToken(t *testing.T) {
	userID := uint(1)
	role := "admin"
	permissions := []string{"read", "write"}
	secretKey := "testsecretkey"

	token, err := GenerateToken(userID, role, permissions, secretKey)
	if err != nil {
		t.Fatalf("GenerateToken failed: %v", err)
	}
	if token == "" {
		t.Error("Expected non-empty token, got empty string")
	}

	// Проверяем, что токен можно разобрать
	parsedToken, err := jwt.Parse(token, func(token *jwt.Token) (interface{}, error) {
		return []byte(secretKey), nil
	})
	if err != nil || !parsedToken.Valid {
		t.Errorf("Generated token is invalid: %v", err)
	}
}

func TestValidateToken(t *testing.T) {
	userID := uint(1)
	role := "admin"
	permissions := []string{"read", "write"}
	secretKey := "testsecretkey"

	token, err := GenerateToken(userID, role, permissions, secretKey)
	if err != nil {
		t.Fatalf("GenerateToken failed: %v", err)
	}

	parsedUserID, parsedRole, parsedPermissions, err := ValidateToken(token, secretKey)
	if err != nil {
		t.Fatalf("ValidateToken failed: %v", err)
	}
	if parsedUserID != userID || parsedRole != role || len(parsedPermissions) != len(permissions) {
		t.Errorf("ValidateToken returned incorrect values: got %d, %s, %v; want %d, %s, %v",
			parsedUserID, parsedRole, parsedPermissions, userID, role, permissions)
	}

	// Тест с истекшим токеном
	claims := Claims{
		UserID:      userID,
		Role:        role,
		Permissions: permissions,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(-24 * time.Hour)),
		},
	}
	expiredToken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	expiredTokenString, _ := expiredToken.SignedString([]byte(secretKey))
	_, _, _, err = ValidateToken(expiredTokenString, secretKey)
	if err == nil {
		t.Error("Expected error for expired token, got nil")
	}
}

func TestGenerateTokenForTest(t *testing.T) {
	userID := uint(1)
	role := "admin"
	permissions := []string{"read", "write"}
	secretKey := "testsecretkey"

	token, err := GenerateTokenForTest(userID, role, permissions, secretKey)
	if err != nil {
		t.Fatalf("GenerateTokenForTest failed: %v", err)
	}
	if token == "" {
		t.Error("Expected non-empty token, got empty string")
	}
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\pkg\errors\errors.go
Содержимое: 
package errors

import (
	"errors"
)

// Определение пользовательских типов ошибок
var (
	ErrInvalidCredentials = errors.New("invalid credentials")
	ErrUserExists         = errors.New("user already exists")
	ErrUserNotFound       = errors.New("user not found")
	ErrTokenCreation      = errors.New("failed to create token")
	ErrDatabaseConnection = errors.New("failed to connect to database")
	ErrInvalidToken       = errors.New("invalid or expired token")
	ErrRoleNotFound       = errors.New("role not found")
	ErrPermissionNotFound = errors.New("permission not found")
	ErrInvalidRoleID      = errors.New("invalid role ID")
	// Добавьте другие пользовательские ошибки по необходимости
)

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\pkg\errors\errors_test.go
Содержимое: 
package errors

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestErrors(t *testing.T) {
	tests := []struct {
		name     string
		err      error
		expected string
	}{
		{
			name:     "ErrUserExists",
			err:      ErrUserExists,
			expected: "user already exists",
		},
		{
			name:     "ErrUserNotFound",
			err:      ErrUserNotFound,
			expected: "user not found",
		},
		{
			name:     "ErrInvalidCredentials",
			err:      ErrInvalidCredentials,
			expected: "invalid credentials",
		},
		{
			name:     "ErrDatabaseConnection",
			err:      ErrDatabaseConnection,
			expected: "failed to connect to database",
		},
		{
			name:     "ErrTokenCreation",
			err:      ErrTokenCreation,
			expected: "failed to create token",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			assert.Equal(t, tt.expected, tt.err.Error())
		})
	}
}

func TestErrorsUniqueness(t *testing.T) {
	// Проверяем, что все ошибки уникальны
	errors := []error{
		ErrUserExists,
		ErrUserNotFound,
		ErrInvalidCredentials,
		ErrDatabaseConnection,
		ErrTokenCreation,
	}

	for i := 0; i < len(errors); i++ {
		for j := i + 1; j < len(errors); j++ {
			assert.NotEqual(t, errors[i], errors[j],
				"Errors should be unique: %v and %v", errors[i], errors[j])
		}
	}
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\pkg\health\health.go
Содержимое: 
package health

import (
	"net/http"
	"runtime"
	"time"

	"backend/pkg/logger"
	"backend/pkg/metrics"

	"github.com/gin-gonic/gin"
)

// PingableDB интерфейс для проверки соединения с базой данных
type PingableDB interface {
	Ping() error
}

// HealthChecker структура для проверки здоровья системы
type HealthChecker struct {
	db PingableDB
}

type HealthStatus struct {
	Status    string `json:"status"`
	Timestamp string `json:"timestamp"`
}

type DetailedHealth struct {
	Status    string `json:"status"`
	Database  string `json:"database"`
	Timestamp string `json:"timestamp"`
}

// NewHealthChecker создает новый экземпляр HealthChecker
func NewHealthChecker(db PingableDB) *HealthChecker {
	return &HealthChecker{
		db: db,
	}
}

// CheckHealth проверяет здоровье системы
func (h *HealthChecker) CheckHealth(c *gin.Context) {
	ctx := c.Request.Context()
	traceID := logger.GetTraceID(ctx)
	start := time.Now()

	status := "UP"
	dbStatus := "UP"
	dbDetails := "Database connection is healthy"

	if err := h.db.Ping(); err != nil {
		status = "DOWN"
		dbStatus = "DOWN"
		dbDetails = "Database connection failed"
		logger.Logger.Error(ctx, "Database ping failed", err)
	} else {
		logger.Logger.Info(ctx, "Health check completed successfully")
	}

	var m runtime.MemStats
	runtime.ReadMemStats(&m)

	duration := time.Since(start).Seconds()
	metrics.HealthCheckDuration.WithLabelValues("full", status).Observe(duration)

	c.JSON(http.StatusOK, gin.H{
		"status":   status,
		"trace_id": traceID,
		"components": gin.H{
			"database": gin.H{
				"status":  dbStatus,
				"details": dbDetails,
			},
			"memory": gin.H{
				"allocated": m.Alloc,
				"total":     m.TotalAlloc,
				"system":    m.Sys,
			},
		},
		"timestamp": time.Now().Format(time.RFC3339),
	})
}

// LivenessProbe проверяет, жив ли сервис
func (h *HealthChecker) LivenessProbe(c *gin.Context) {
	ctx := c.Request.Context()
	traceID := logger.GetTraceID(ctx)
	start := time.Now()

	logger.Logger.Info(ctx, "Liveness probe checked")

	duration := time.Since(start).Seconds()
	metrics.HealthCheckDuration.WithLabelValues("liveness", "UP").Observe(duration)

	c.JSON(http.StatusOK, gin.H{
		"status":   "UP",
		"trace_id": traceID,
	})
}

// ReadinessProbe проверяет, готов ли сервис обрабатывать запросы
func (h *HealthChecker) ReadinessProbe(c *gin.Context) {
	ctx := c.Request.Context()
	traceID := logger.GetTraceID(ctx)
	start := time.Now()

	if err := h.db.Ping(); err != nil {
		logger.Logger.Error(ctx, "Readiness probe failed: database unavailable", err)
		duration := time.Since(start).Seconds()
		metrics.HealthCheckDuration.WithLabelValues("readiness", "DOWN").Observe(duration)
		c.JSON(http.StatusServiceUnavailable, gin.H{
			"status":   "DOWN",
			"reason":   "Database connection failed",
			"trace_id": traceID,
		})
		return
	}

	logger.Logger.Info(ctx, "Readiness probe succeeded")
	duration := time.Since(start).Seconds()
	metrics.HealthCheckDuration.WithLabelValues("readiness", "UP").Observe(duration)

	c.JSON(http.StatusOK, gin.H{
		"status":   "UP",
		"trace_id": traceID,
	})
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\pkg\health\health_test.go
Содержимое: 
package health

import (
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
)

// MockDB мок для базы данных
type MockDB struct {
	mock.Mock
}

func (m *MockDB) Ping() error {
	args := m.Called()
	return args.Error(0)
}

// Ensure MockDB implements PingableDB
var _ PingableDB = (*MockDB)(nil)

func TestHealthChecker_CheckHealth(t *testing.T) {
	gin.SetMode(gin.TestMode)

	tests := []struct {
		name       string
		setupMock  func(*MockDB)
		wantStatus int
		wantBody   map[string]interface{}
	}{
		{
			name: "Healthy",
			setupMock: func(db *MockDB) {
				db.On("Ping").Return(nil)
			},
			wantStatus: http.StatusOK,
			wantBody: map[string]interface{}{
				"status": "UP",
				"components": map[string]interface{}{
					"database": map[string]interface{}{
						"status":  "UP",
						"details": "Database connection is healthy",
					},
				},
			},
		},
		{
			name: "Unhealthy",
			setupMock: func(db *MockDB) {
				db.On("Ping").Return(assert.AnError)
			},
			wantStatus: http.StatusOK,
			wantBody: map[string]interface{}{
				"status": "DOWN",
				"components": map[string]interface{}{
					"database": map[string]interface{}{
						"status":  "DOWN",
						"details": "Database connection failed",
					},
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Создаем мок и настраиваем его
			mockDB := new(MockDB)
			tt.setupMock(mockDB)

			// Создаем HealthChecker
			checker := NewHealthChecker(mockDB)

			// Создаем тестовый контекст
			w := httptest.NewRecorder()
			c, _ := gin.CreateTestContext(w)

			// Выполняем проверку
			checker.CheckHealth(c)

			// Проверяем статус код
			assert.Equal(t, tt.wantStatus, w.Code)

			// Проверяем тело ответа
			var got map[string]interface{}
			err := json.Unmarshal(w.Body.Bytes(), &got)
			assert.NoError(t, err)

			// Удаляем timestamp из ответа, так как он динамический
			delete(got, "timestamp")

			assert.Equal(t, tt.wantBody, got)

			// Проверяем, что все ожидаемые вызовы были выполнены
			mockDB.AssertExpectations(t)
		})
	}
}

func TestHealthChecker_LivenessProbe(t *testing.T) {
	gin.SetMode(gin.TestMode)

	// Создаем мок
	mockDB := new(MockDB)

	// Создаем HealthChecker
	checker := NewHealthChecker(mockDB)

	// Создаем тестовый контекст
	w := httptest.NewRecorder()
	c, _ := gin.CreateTestContext(w)

	// Выполняем проверку
	checker.LivenessProbe(c)

	// Проверяем статус код
	assert.Equal(t, http.StatusOK, w.Code)

	// Проверяем тело ответа
	var got map[string]interface{}
	err := json.Unmarshal(w.Body.Bytes(), &got)
	assert.NoError(t, err)

	assert.Equal(t, map[string]interface{}{
		"status": "UP",
	}, got)
}

func TestHealthChecker_ReadinessProbe(t *testing.T) {
	gin.SetMode(gin.TestMode)

	tests := []struct {
		name       string
		setupMock  func(*MockDB)
		wantStatus int
		wantBody   map[string]interface{}
	}{
		{
			name: "Ready",
			setupMock: func(db *MockDB) {
				db.On("Ping").Return(nil)
			},
			wantStatus: http.StatusOK,
			wantBody: map[string]interface{}{
				"status": "UP",
			},
		},
		{
			name: "Not Ready",
			setupMock: func(db *MockDB) {
				db.On("Ping").Return(assert.AnError)
			},
			wantStatus: http.StatusServiceUnavailable,
			wantBody: map[string]interface{}{
				"status": "DOWN",
				"reason": "Database connection failed",
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Создаем мок и настраиваем его
			mockDB := new(MockDB)
			tt.setupMock(mockDB)

			// Создаем HealthChecker
			checker := NewHealthChecker(mockDB)

			// Создаем тестовый контекст
			w := httptest.NewRecorder()
			c, _ := gin.CreateTestContext(w)

			// Выполняем проверку
			checker.ReadinessProbe(c)

			// Проверяем статус код
			assert.Equal(t, tt.wantStatus, w.Code)

			// Проверяем тело ответа
			var got map[string]interface{}
			err := json.Unmarshal(w.Body.Bytes(), &got)
			assert.NoError(t, err)

			assert.Equal(t, tt.wantBody, got)

			// Проверяем, что все ожидаемые вызовы были выполнены
			mockDB.AssertExpectations(t)
		})
	}
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\pkg\logger\logger.go
Содержимое: 
package logger

import (
	"context"
	"fmt"
	"io"
	"log/slog"
	"os"
	"path/filepath"
	"time"

	"gopkg.in/natefinch/lumberjack.v2"
)

type ctxKey string

const (
	TraceIDKey   ctxKey = "trace_id" // Обновляем имя ключа для консистентности
	RequestIDKey ctxKey = "request_id"
)

// LogLevel представляет уровень логирования
type LogLevel int

const (
	LevelDebug LogLevel = iota
	LevelInfo
	LevelWarn
	LevelError
)

// Logger представляет собой глобальный логгер приложения
var Logger *AppLogger

// AppLogger - обертка над slog.Logger с дополнительными методами
type AppLogger struct {
	slog *slog.Logger
	opts Options
}

// Options содержит настройки логгера
type Options struct {
	Level     LogLevel
	AddSource bool
	Output    io.Writer
	Timezone  *time.Location
	Format    string
}

// DefaultOptions возвращает настройки по умолчанию
func DefaultOptions() Options {
	return Options{
		Level:     LevelDebug,
		AddSource: true,
		Output:    os.Stdout,
		Timezone:  time.UTC,
		Format:    "text",
	}
}

// InitLogger инициализирует глобальный логгер с заданными параметрами
func InitLogger(level string, output string, filePath string, maxSize int, maxBackups int, maxAge int, compress bool, timezone string, format string) error {
	var logLevel LogLevel
	switch level {
	case "debug":
		logLevel = LevelDebug
	case "info":
		logLevel = LevelInfo
	case "warn":
		logLevel = LevelWarn
	case "error":
		logLevel = LevelError
	default:
		logLevel = LevelInfo
	}

	var logOutput io.Writer
	switch output {
	case "console":
		logOutput = os.Stdout
	case "file":
		if err := os.MkdirAll(filepath.Dir(filePath), 0755); err != nil {
			return fmt.Errorf("failed to create log directory: %w", err)
		}
		logOutput = &lumberjack.Logger{
			Filename:   filePath,
			MaxSize:    maxSize,
			MaxBackups: maxBackups,
			MaxAge:     maxAge,
			Compress:   compress,
		}
	default:
		logOutput = os.Stdout
	}

	loc, err := time.LoadLocation(timezone)
	if err != nil {
		return fmt.Errorf("failed to load timezone %s: %w", timezone, err)
	}

	opts := Options{
		Level:     logLevel,
		AddSource: true,
		Output:    logOutput,
		Timezone:  loc,
		Format:    format,
	}
	Logger = NewLogger(opts)
	return nil
}

// NewLogger создает новый логгер с указанными настройками
func NewLogger(opts Options) *AppLogger {
	handler := newHandler(opts)
	return &AppLogger{
		slog: slog.New(handler),
		opts: opts,
	}
}

// newHandler создает новый обработчик логов с поддержкой формата и часового пояса
func newHandler(opts Options) slog.Handler {
	level := convertLevel(opts.Level)
	handlerOpts := &slog.HandlerOptions{
		AddSource: opts.AddSource,
		Level:     level,
		ReplaceAttr: func(groups []string, a slog.Attr) slog.Attr {
			if a.Key == slog.TimeKey {
				return slog.Attr{
					Key:   a.Key,
					Value: slog.TimeValue(a.Value.Time().In(opts.Timezone)),
				}
			}
			return a
		},
	}

	if opts.Format == "json" {
		return slog.NewJSONHandler(opts.Output, handlerOpts)
	}
	return slog.NewTextHandler(opts.Output, handlerOpts)
}

// convertLevel конвертирует LogLevel в slog.Level
func convertLevel(level LogLevel) slog.Level {
	switch level {
	case LevelInfo:
		return slog.LevelInfo
	case LevelWarn:
		return slog.LevelWarn
	case LevelError:
		return slog.LevelError
	default:
		return slog.LevelDebug
	}
}

// SetLevel устанавливает новый уровень логирования
func (l *AppLogger) SetLevel(level LogLevel) {
	l.opts.Level = level
	l.slog = slog.New(newHandler(l.opts))
}

// WithContext создает новый логгер с контекстом
func (l *AppLogger) WithContext(ctx context.Context) *AppLogger {
	if ctx == nil {
		return l
	}

	fields := make([]interface{}, 0)

	if traceID := GetTraceID(ctx); traceID != "" {
		fields = append(fields, "trace_id", traceID)
	}

	if requestID, ok := ctx.Value(RequestIDKey).(string); ok && requestID != "" {
		fields = append(fields, "request_id", requestID)
	}

	if len(fields) == 0 {
		return l
	}

	return &AppLogger{
		slog: l.slog.With(fields...),
		opts: l.opts,
	}
}

// GetTraceID возвращает ID трассировки из контекста
func GetTraceID(ctx context.Context) string {
	if ctx == nil {
		return ""
	}
	if traceID, ok := ctx.Value(TraceIDKey).(string); ok {
		return traceID
	}
	return ""
}

// log логирует сообщение с указанным уровнем и атрибутами
func (l *AppLogger) log(ctx context.Context, level slog.Level, msg string, attrs ...any) {
	if ctx != nil {
		// Автоматически добавляем trace_id из контекста, если он есть
		if traceID := GetTraceID(ctx); traceID != "" {
			attrs = append(attrs, "trace_id", traceID)
		}
		// Добавляем request_id, если он есть
		if requestID, ok := ctx.Value(RequestIDKey).(string); ok && requestID != "" {
			attrs = append(attrs, "request_id", requestID)
		}
	}
	l.slog.Log(ctx, level, msg, attrs...)
}

// logf логирует форматированное сообщение с указанным уровнем
func (l *AppLogger) logf(level slog.Level, format string, args ...interface{}) {
	l.log(context.TODO(), level, fmt.Sprintf(format, args...))
}

// Debug логирует отладочное сообщение
func (l *AppLogger) Debug(ctx context.Context, msg string, attrs ...any) {
	l.log(ctx, slog.LevelDebug, msg, attrs...)
}

// Debugf логирует форматированное отладочное сообщение
func (l *AppLogger) Debugf(format string, args ...interface{}) {
	l.logf(slog.LevelDebug, format, args...)
}

// Info логирует информационное сообщение
func (l *AppLogger) Info(ctx context.Context, msg string, attrs ...any) {
	l.log(ctx, slog.LevelInfo, msg, attrs...)
}

// Infof логирует форматированное информационное сообщение
func (l *AppLogger) Infof(format string, args ...interface{}) {
	l.logf(slog.LevelInfo, format, args...)
}

// Warn логирует предупреждение
func (l *AppLogger) Warn(ctx context.Context, msg string, attrs ...any) {
	l.log(ctx, slog.LevelWarn, msg, attrs...)
}

// Warnf логирует форматированное предупреждение
func (l *AppLogger) Warnf(format string, args ...interface{}) {
	l.logf(slog.LevelWarn, format, args...)
}

// Error логирует ошибку
func (l *AppLogger) Error(ctx context.Context, msg string, err error, attrs ...any) {
	if err != nil {
		attrs = append(attrs, "error", err, "stack", fmt.Sprintf("%+v", err))
	}
	l.log(ctx, slog.LevelError, msg, attrs...)
}

// Errorf логирует форматированное сообщение об ошибке
func (l *AppLogger) Errorf(format string, args ...interface{}) {
	l.logf(slog.LevelError, format, args...)
}

// Методы без контекста для обратной совместимости
func (l *AppLogger) InfoNoCtx(msg string, attrs ...any) {
	l.log(context.Background(), slog.LevelInfo, msg, attrs...)
}

func (l *AppLogger) ErrorNoCtx(msg string, err error, attrs ...any) {
	if err != nil {
		attrs = append(attrs, "error", err)
	}
	l.log(context.Background(), slog.LevelError, msg, attrs...)
}

// NewTestLogger создает новый логгер для тестов
func NewTestLogger(w io.Writer) *AppLogger {
	return NewLogger(Options{
		Level:     LevelDebug,
		AddSource: true,
		Output:    w,
		Timezone:  time.UTC,
		Format:    "text",
	})
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\pkg\logger\logger_test.go
Содержимое: 
package logger

import (
	"bytes"
	"context"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestLogger(t *testing.T) {
	oldLogger := Logger
	defer func() { Logger = oldLogger }()

	Logger = NewLogger(Options{
		Level:     LevelDebug,
		AddSource: true,
		Output:    &bytes.Buffer{},
	})

	ctx := context.Background()

	tests := []struct {
		name     string
		logFunc  func()
		wantText string
	}{
		{
			name: "Info",
			logFunc: func() {
				Logger.Info(ctx, "test info")
			},
			wantText: "test info",
		},
		{
			name: "Debug",
			logFunc: func() {
				Logger.Debug(ctx, "test debug")
			},
			wantText: "test debug",
		},
		{
			name: "InfoNoCtx",
			logFunc: func() {
				Logger.InfoNoCtx("test no ctx")
			},
			wantText: "test no ctx",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			tt.logFunc()
		})
	}
}

func TestLoggerWithContext(t *testing.T) {
	oldLogger := Logger
	defer func() { Logger = oldLogger }()

	buf := &bytes.Buffer{}
	Logger = NewLogger(Options{
		Level:     LevelDebug,
		AddSource: true,
		Output:    buf,
	})

	// Создаем контекст с тестовыми данными
	ctx := context.WithValue(context.Background(), RequestIDKey, "test-id")

	// Логируем сообщение с контекстом
	Logger.Info(ctx, "test with context")

	// Проверяем, что лог содержит все необходимые поля
	output := buf.String()
	assert.Contains(t, output, "level=INFO")
	assert.Contains(t, output, "test with context")
	assert.Contains(t, output, "request_id=test-id")
}

func TestLoggerLevels(t *testing.T) {
	oldLogger := Logger
	defer func() { Logger = oldLogger }()

	buf := &bytes.Buffer{}
	Logger = NewLogger(Options{
		Level:     LevelDebug,
		AddSource: true,
		Output:    buf,
	})

	ctx := context.Background()

	// Debug сообщение
	Logger.Debug(ctx, "test debug")
	assert.Contains(t, buf.String(), "test debug")

	// Info сообщение
	buf.Reset()
	Logger.Info(ctx, "test info")
	assert.Contains(t, buf.String(), "test info")

	// Warn сообщение
	buf.Reset()
	Logger.Warn(ctx, "test warn")
	assert.Contains(t, buf.String(), "test warn")

	// Error сообщение
	buf.Reset()
	Logger.Error(ctx, "test error", assert.AnError)
	assert.Contains(t, buf.String(), "test error")
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\pkg\metrics\metrics.go
Содержимое: 
package metrics

import (
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
	// HTTPRequestsTotal считает общее количество HTTP запросов
	HTTPRequestsTotal = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "http_requests_total",
			Help: "Total number of HTTP requests",
		},
		[]string{"method", "endpoint", "status"},
	)

	// HTTPRequestDuration измеряет длительность HTTP запросов
	HTTPRequestDuration = prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "http_request_duration_seconds",
			Help:    "HTTP request duration in seconds",
			Buckets: []float64{.005, .01, .025, .05, .1, .25, .5, 1, 2.5, 5, 10},
		},
		[]string{"method", "endpoint"},
	)

	// DatabaseQueriesTotal считает общее количество запросов к БД
	DatabaseQueriesTotal = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "database_queries_total",
			Help: "Total number of database queries",
		},
		[]string{"type", "status"},
	)

	// DatabaseErrors считает общее количество ошибок базы данных
	DatabaseErrors = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "database_errors_total",
			Help: "Total number of database errors",
		},
		[]string{"type"},
	)

	// DatabaseSpecificErrors считает специфические ошибки базы данных (дедлоки, таймауты)
	DatabaseSpecificErrors = prometheus.NewCounterVec(
		prometheus.CounterOpts{
			Name: "database_specific_errors_total",
			Help: "Total number of specific database errors (e.g., deadlocks, timeouts)",
		},
		[]string{"error_type"},
	)

	// ActiveConnections показывает текущее количество активных соединений (HTTP)
	ActiveConnections = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "active_connections",
			Help: "Number of currently active connections",
		},
	)

	// HealthCheckDuration измеряет длительность проверок здоровья
	HealthCheckDuration = prometheus.NewHistogramVec(
		prometheus.HistogramOpts{
			Name:    "health_check_duration_seconds",
			Help:    "Duration of health checks in seconds",
			Buckets: []float64{.005, .01, .025, .05, .1, .25, .5, 1},
		},
		[]string{"type", "status"},
	)

	// DBOpenConnections показывает текущее количество открытых соединений с базой данных
	DBOpenConnections = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "db_open_connections",
			Help: "Number of open database connections",
		},
	)

	// DBIdleConnections показывает текущее количество простаивающих соединений с базой данных
	DBIdleConnections = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "db_idle_connections",
			Help: "Number of idle database connections",
		},
	)

	// DBMaxOpenConnections показывает максимальное количество открытых соединений, заданное в конфигурации
	DBMaxOpenConnections = prometheus.NewGauge(
		prometheus.GaugeOpts{
			Name: "db_max_open_connections",
			Help: "Maximum number of open database connections allowed",
		},
	)
)

func init() {
	// Регистрируем метрики в Prometheus
	prometheus.MustRegister(HTTPRequestsTotal)
	prometheus.MustRegister(HTTPRequestDuration)
	prometheus.MustRegister(DatabaseQueriesTotal)
	prometheus.MustRegister(DatabaseErrors)
	prometheus.MustRegister(DatabaseSpecificErrors)
	prometheus.MustRegister(ActiveConnections)
	prometheus.MustRegister(HealthCheckDuration)
	prometheus.MustRegister(DBOpenConnections)
	prometheus.MustRegister(DBIdleConnections)
	prometheus.MustRegister(DBMaxOpenConnections)
}

// PrometheusMiddleware добавляет сбор метрик для HTTP запросов
func PrometheusMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		start := time.Now()
		path := c.Request.URL.Path

		ActiveConnections.Inc()
		defer ActiveConnections.Dec()

		c.Next()

		status := c.Writer.Status()
		duration := time.Since(start).Seconds()

		HTTPRequestsTotal.WithLabelValues(
			c.Request.Method,
			path,
			strconv.Itoa(status),
		).Inc()

		HTTPRequestDuration.WithLabelValues(
			c.Request.Method,
			path,
		).Observe(duration)
	}
}

// PrometheusHandler возвращает handler для эндпоинта метрик
func PrometheusHandler() gin.HandlerFunc {
	h := promhttp.Handler()
	return func(c *gin.Context) {
		h.ServeHTTP(c.Writer, c.Request)
	}
}

--------------------------------------------------------------------------------
Путь: d:\golang\DTT\backend\pkg\metrics\metrics_test.go
Содержимое: 
package metrics

import (
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/gin-gonic/gin"
	"github.com/stretchr/testify/assert"
)

func TestPrometheus(t *testing.T) {
	// Настраиваем тестовое окружение
	gin.SetMode(gin.TestMode)
	router := gin.New()
	router.Use(PrometheusMiddleware())
	router.GET("/metrics", PrometheusHandler())
	router.GET("/test", func(c *gin.Context) {
		c.Status(http.StatusOK)
	})
	router.GET("/notfound", func(c *gin.Context) {
		c.Status(http.StatusNotFound)
	})
	router.POST("/create", func(c *gin.Context) {
		c.Status(http.StatusCreated)
	})

	t.Run("проверка сбора метрик для успешного GET-запроса", func(t *testing.T) {
		w := httptest.NewRecorder()
		req := httptest.NewRequest("GET", "/test", nil)
		router.ServeHTTP(w, req)
		assert.Equal(t, http.StatusOK, w.Code)

		// Проверяем метрики
		w = httptest.NewRecorder()
		req = httptest.NewRequest("GET", "/metrics", nil)
		router.ServeHTTP(w, req)
		assert.Equal(t, http.StatusOK, w.Code)
		body := w.Body.String()

		assert.Contains(t, body, `http_requests_total{method="GET",endpoint="/test",status="200"}`)
		assert.Contains(t, body, `http_request_duration_seconds_count{method="GET",endpoint="/test"}`)
		assert.Contains(t, body, "active_connections")
	})

	t.Run("проверка сбора метрик для ошибки 404", func(t *testing.T) {
		w := httptest.NewRecorder()
		req := httptest.NewRequest("GET", "/notfound", nil)
		router.ServeHTTP(w, req)
		assert.Equal(t, http.StatusNotFound, w.Code)

		// Проверяем метрики
		w = httptest.NewRecorder()
		req = httptest.NewRequest("GET", "/metrics", nil)
		router.ServeHTTP(w, req)
		assert.Equal(t, http.StatusOK, w.Code)
		body := w.Body.String()

		assert.Contains(t, body, `http_requests_total{method="GET",endpoint="/notfound",status="404"}`)
		assert.Contains(t, body, `http_request_duration_seconds_count{method="GET",endpoint="/notfound"}`)
		assert.Contains(t, body, "active_connections")
	})

	t.Run("проверка сбора метрик для POST-запроса", func(t *testing.T) {
		w := httptest.NewRecorder()
		req := httptest.NewRequest("POST", "/create", nil)
		router.ServeHTTP(w, req)
		assert.Equal(t, http.StatusCreated, w.Code)

		// Проверяем метрики
		w = httptest.NewRecorder()
		req = httptest.NewRequest("GET", "/metrics", nil)
		router.ServeHTTP(w, req)
		assert.Equal(t, http.StatusOK, w.Code)
		body := w.Body.String()

		assert.Contains(t, body, `http_requests_total{method="POST",endpoint="/create",status="201"}`)
		assert.Contains(t, body, `http_request_duration_seconds_count{method="POST",endpoint="/create"}`)
		assert.Contains(t, body, "active_connections")
	})
}

--------------------------------------------------------------------------------
